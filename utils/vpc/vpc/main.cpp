//===================== Copyright (c) Valve Corporation. All Rights Reserved. ======================
//==================================================================================================

#include "vpc.h"
#include "dependencies.h"
#include "p4sln.h"
#include "ilaunchabledll.h"
#include "bundled_module_info.h"
#include "tier1/interface.h"
#include "tier1/keyvalues.h"

DEFINE_LOGGING_CHANNEL_NO_TAGS( LOG_VPC, "VPC" );

#define VPC_CACHE_EXTENSION			"vpc_cache"
#define VPC_CACHE_VERSION			1

CVPC	*g_pVPC;

// Stuff that we might encounter in a vpc file that parts of vpc care about
const char					*g_pOption_ImportLibrary = "$ImportLibrary";
const char					*g_pOption_OutputFile = "$OutputFile";
const char					*g_pOption_AdditionalDependencies = "$AdditionalDependencies";
const char					*g_pOption_OrderOnlyFileDependencies = "$OrderOnlyFileDependencies";
const char					*g_pOption_OrderOnlyProjectDependencies = "$OrderOnlyProjectDependencies";
const char					*g_pOption_AdditionalDependencies_Proj = "$AdditionalDependencies_Proj";
const char					*g_pOption_AdditionalIncludeDirectories = "$AdditionalIncludeDirectories";
const char					*g_pOption_AdditionalProjectDependencies = "$AdditionalProjectDependencies";
const char					*g_pOption_AdditionalOutputFiles = "$AdditionalOutputFiles";
const char					*g_pOption_PreprocessorDefinitions = "$PreprocessorDefinitions";
const char					*g_pOption_PrecompiledHeader = "$Create/UsePrecompiledHeader";
const char					*g_pOption_UsePCHThroughFile = "$Create/UsePCHThroughFile";
const char					*g_pOption_PrecompiledHeaderFile = "$PrecompiledHeaderFile";
const char					*g_pOption_ForceInclude = "$ForceIncludes";
const char					*g_pOption_ExcludedFromBuild = "$ExcludedFromBuild";
const char					*g_pOption_CommandLine = "$CommandLine";
const char					*g_pOption_ConfigurationType = "$ConfigurationType";
const char					*g_pOption_Description = "$Description";
const char					*g_pOption_GCC_ExtraCompilerFlags = "$GCC_ExtraCompilerFlags";
const char					*g_pOption_GCC_ExtraCxxCompilerFlags = "$GCC_ExtraCxxCompilerFlags";
const char					*g_pOption_GCC_ExtraLinkerFlags = "$GCC_ExtraLinkerFlags";
const char					*g_pOption_POSIX_RPaths = "$POSIX_RPaths";
const char					*g_pOption_GameOutputFile = "$GameOutputFile";
const char					*g_pOption_LocalFrameworks = "$LocalFrameworks";
const char					*g_pOption_OptimizerLevel = "$OptimizerLevel";
const char					*g_pOption_Outputs = "$Outputs";
const char					*g_pOption_PotentialOutputs = "$PotentialOutputs"; //outputs that don't contribute to timestamp triggers, but might be output by the tool (Makefiles needs to know their timestamp *might* change)
const char					*g_pOption_PostBuildEvent = "$PostBuildEvent";
const char					*g_pOption_SymbolVisibility = "$SymbolVisibility";
const char					*g_pOption_SystemFrameworks = "$SystemFrameworks";
const char					*g_pOption_SystemLibraries = "$SystemLibraries";
const char					*g_pOption_BuildMultiArch = "$BuildMultiArch";
const char                  *g_pOption_TreatWarningsAsErrors = "$TreatWarningsAsErrors";
const char					*g_pOption_DisableLinkerDeadCodeElimination = "$DisableLinkerDeadCodeElimination";

const char					*g_VPCGeneratedFolderName = "_vpc_";
const char					*g_QtFolderName = "GENERATED - DO NOT MODIFY OR CHECK IN";
const char					*g_SchemaFolderName = "Autogenerated Schema Files";
const char					*g_SchemaAnchorBase = "_schema_anchor";
const char					*g_IncludeSeparators[2] = {";",","};

bool VPC_IsPlatformWindows( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "WIN32" ) ||
            !V_stricmp_fast( pPlatformName, "WIN64" );
}

bool VPC_IsPlatformLinux( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "LINUX64" ) ||
			!V_stricmp_fast( pPlatformName, "LINUX32" ) ||
            !V_stricmp_fast( pPlatformName, "LINUXSERVER64" ) ||
            !V_stricmp_fast( pPlatformName, "LINUXSTEAMRTARM32HF" ) ||
            !V_stricmp_fast( pPlatformName, "LINUXSTEAMRTARM64HF" );
}

bool VPC_IsPlatformOSX( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "OSX32" ) ||
            !V_stricmp_fast( pPlatformName, "OSX64" );
}

bool VPC_IsPlatformAndroid( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "ANDROIDARM32" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDARM64" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDMIPS32" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDMIPS64" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDX8632" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDX8664" );
}

bool VPC_IsPlatform32Bits( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "ANDROIDARM32" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDMIPS32" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDX8632" ) ||
			!V_stricmp_fast( pPlatformName, "LINUXSTEAMRTARM32HF" ) ||
			!V_stricmp_fast( pPlatformName, "LINUX32" ) ||
			!V_stricmp_fast( pPlatformName, "OSX32" ) ||
			!V_stricmp_fast( pPlatformName, "WIN32" );
}

bool VPC_IsPlatform64Bits( const char *pPlatformName )
{
	return	!V_stricmp_fast( pPlatformName, "ANDROIDARM64" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDMIPS64" ) ||
			!V_stricmp_fast( pPlatformName, "ANDROIDX8664" ) ||
			!V_stricmp_fast( pPlatformName, "LINUX64" ) ||
            !V_stricmp_fast( pPlatformName, "LINUXSERVER64" ) ||
            !V_stricmp_fast( pPlatformName, "LINUXSTEAMRTARM64HF" ) ||
			!V_stricmp_fast( pPlatformName, "OSX64" ) ||
			!V_stricmp_fast( pPlatformName, "WIN64" );
}

class CHostVPCMacro : public CMacro
{
private:
	CHostVPCMacro();

public:
	static void ResolveHostVPCMacro( CMacro *pThis )
	{
		const char *pProjectPath = g_pVPC->GetProjectPath();
		if ( !pProjectPath )
		{
			g_pVPC->VPCError( "$HOST_VPC_EXE only evaluates relative to a project" );
			UNREACHABLE();
		}
		
		char szExecutablePath[MAX_PATH * 2];
		if ( !Plat_GetExecutablePath( szExecutablePath, ARRAYSIZE( szExecutablePath ) ) )
		{
			g_pVPC->VPCError( "$HOST_VPC_EXE could not determine the path of the vpc executable" );
			UNREACHABLE();
		}

		char szRelative[MAX_PATH * 2];
		if ( !V_MakeRelativePath( szExecutablePath, pProjectPath, szRelative, ARRAYSIZE( szRelative ) ) )
		{
			g_pVPC->VPCWarning( "$HOST_VPC_EXE could not turn the absolute path to a relative one" );
			V_strncpy( szRelative, szExecutablePath, ARRAYSIZE(szRelative) );
		}

		if ( ((CHostVPCMacro *)pThis)->m_Value != szRelative )
		{
			((CHostVPCMacro *)pThis)->m_Value = szRelative;
		}
	}
};

#ifdef POSIX
#define _unlink unlink
#define _mktemp mktemp
#endif

CVPC::CVPC()
{
	m_pP4Module = NULL;
	m_pFilesystemModule = NULL;

	m_nArgc = 0;
	m_ppArgv = NULL;

	m_bVerbose = false;
	m_bQuiet = false;
	m_bQuietValidSpew = false;
	m_bUsageOnly = false;
	m_bHelp = false;
	m_bSpewPlatforms = false;
	m_bSpewGames = false;
	m_bSpewGroups = false;
	m_bSpewProjects = false;
	m_bIgnoreRedundancyWarning = false;
	m_bSpewProperties = false;
	m_bTestMode = false;
    m_bInProjectSection = false;
	m_bGeneratedProject = false;
	m_bAnyProjectQualified = false;
	m_bForceGenerate = false;
	m_bEnableVpcGameMacro = true;
	m_bDecorateProject = false;
	m_bShowDeps = false;
	m_bP4AutoAdd = false;
	m_bIsDependencyPass = false;
	m_bPreferVS2010 = false;
	m_bUse2010 = false;
	m_bPreferVS2012 = false;
	m_bUse2012 = false;
	m_bPreferVS2013 = false;
	m_bUse2013 = false;
	m_bPreferVS2015 = true;
	m_bUse2015 = false;
	m_bShallowDepencies = false;
	m_nFilesMissing = 0;
	m_nTotalFilesMissing = 0;
	m_bCheckFiles = false;
	m_bSourceControl = false;
	m_bAllowOSMacro = false;
	m_bCRCCheckInProject = false;
	m_bMissingFileIsError = false;
	m_bAllowFilePattern = false;
	m_bAddExecuteableToCRC = false;
	m_bRestrictProjects = true;
	m_bForceRebuildCache = false;
	m_bShowFixedPaths = false;
	m_bShowCaseIssues = false;
    m_bGenMakeProj = false;
    m_bPerFileCompileConfig = true;
    m_bAllowLibWithinLib = true;

	m_bAllowQt = false;
	m_bAllowSchema = false;
	m_bAllowUnity = false;
	m_bUnitySchemaHeadersOnly = true;
	m_bUnityOnWritableFiles = false;

	m_bAllowClang = false;
	m_bEmitClangProject = false;
	m_bAddUnitySuffix = false;
	m_bProjectUsesUnity = false;

	m_bForceIterate = false;

	m_bDedicatedBuild = false;
	m_bAppendSrvToDedicated = false;
	m_bUseValveBinDir = false;

	m_pProjectGenerator = NULL;
	m_pSolutionGenerator = NULL;
	m_pSolutionGenerator2 = NULL;

    m_TempStringBuffer1.EnsureCapacity( 100000 );
    m_TempStringBuffer2.EnsureCapacity( 100000 );
    m_MacroReplaceBuffer.EnsureCapacity( 100000 );
    m_PropertyValueBuffer.EnsureCapacity( 100000 );
    
	m_pDependencyProject = nullptr;

	ClearPacifier();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CVPC::~CVPC()
{
	Shutdown( false );
}

void CVPC::SetVerbosityFromCommandLineArgs()
{
	// vpc operates tersely by preferred company opinion
	// verbosity necessary for debugging 
	m_bVerbose = ( HasCommandLineParameter( "/v" ) || HasCommandLineParameter( "/verbose" ) );

	m_bQuiet = ( HasCommandLineParameter( "/q" ) || 
		HasCommandLineParameter( "/quiet" ) || 
		( Plat_GetEnv( "VPC_QUIET" ) && V_stricmp_fast( Plat_GetEnv( "VPC_QUIET" ), "0" ) ) );

	m_bQuietValidSpew = HasCommandLineParameter( "/qv" );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool CVPC::Init( int argc, char **argv )
{
	// need to use the raw command line for early arg parsing until AFTER any potential restart
	m_nArgc = argc;
	m_ppArgv = (const char **)argv;

	// early setup of verbosity for debugging
	SetVerbosityFromCommandLineArgs();

	// the enhanced CommandLine() gets built by tier0 to pick up app autoargs
	// the additional autoargs can't reliably be consumed until AFTER the restart
	// because they could be from the wrong branch
	CommandLine()->CreateCmdLine( argc, argv );

#ifndef STEAM
	// We don't really need to pop the logging state since the process will terminate when we're done.
	LoggingSystem_PushLoggingState();

	m_LoggingListener.m_bQuietPrintf = m_bQuiet;
	LoggingSystem_RegisterLoggingListener( &m_LoggingListener );
#endif

	InProcessCRCCheck();

	// vpc may have been run from wrong location, restart self
	bool bIsRestart = false;
	if ( RestartFromCorrectLocation( &bIsRestart ) )
	{
		// successfully ran under restart condition, all done
		return false;
	}

	// either restarted (from the correct location with correct defaults) or not, NOW the enhanced CL can be used instead
	// not using the argument parser, but absolutely want the enhanced CL from tier0 which supports app autoargs
	m_nArgc = CommandLine()->ParmCount();
	m_ppArgv = CommandLine()->GetParms();

	// autoargs may have verbosity settings, so redo
	SetVerbosityFromCommandLineArgs();

	LoadPerforceInterface();

	// Emit the Date/Time to solve errors on user's machines as running the-expected-vpc.
	Log_Msg( LOG_VPC, "VPC - Valve Project Creator (Build: %s %s)\n", __DATE__, __TIME__ );
	Log_Msg( LOG_VPC, "Copyright (c) Valve Corporation. All Rights Reserved.\n" );
	Log_Msg( LOG_VPC, "\n" );

	return true;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::Shutdown( bool bHasError )
{
	if ( !bHasError )
	{
		GetScript().EnsureScriptStackEmpty();
	}

	if ( !m_TempGroupScriptFilename.IsEmpty() )
	{
		// delete temp work file
		_unlink( m_TempGroupScriptFilename.Get() );
		m_TempGroupScriptFilename.Clear();
	}
	
	UnloadPerforceInterface();

	LoggingSystem_UnregisterLoggingListener( &m_LoggingListener );

	if ( bHasError )
	{
		// errors are fatal
		exit( 1 );
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool CVPC::LoadPerforceInterface()
{
#if defined( POSIX )
	return false;
#endif

	if ( p4 )
	{
		// already loaded
		return true;
	}


	//
	// Try to load p4lib.dll and the filesystem since the p4lib relies on it
	//
	char dllsPath[MAX_FIXED_PATH];
	char p4libdll[MAX_FIXED_PATH];
	char filesystemdll[MAX_FIXED_PATH];
	
#ifdef _WIN32
	
	// Load dll's from devtools\bin as the ones in game/bin may have vpc-breaking changes
	char szModuleBinPath[MAX_FIXED_PATH];
	
#define DLLSUBDIRPATH	"."

	GetModuleFileName( NULL, szModuleBinPath, sizeof( szModuleBinPath ) );
	V_ExtractFilePath( szModuleBinPath, dllsPath, sizeof( dllsPath ) );
	V_strncat( dllsPath, DLLSUBDIRPATH, sizeof( dllsPath ) );

	V_strncpy( p4libdll, dllsPath, sizeof( filesystemdll ) );
	V_strncat( p4libdll, "\\p4lib.dll", sizeof( p4libdll ) );	
			
	V_strncpy( filesystemdll, dllsPath, sizeof( filesystemdll ) );
	V_strncat( filesystemdll, "\\filesystem_stdio.dll", sizeof( filesystemdll ) );	

#else
	V_strncpy( p4libdll, "p4lib", sizeof( p4libdll ) );
    filesystemdll[0] = 0;
	V_strncat( filesystemdll, "\\filesystem_stdio.dll", sizeof( filesystemdll ) );

#endif

	
	if ( !Sys_LoadInterface( p4libdll, P4_INTERFACE_VERSION, (CSysModule**)&m_pP4Module, ( void** )&p4 ) )
	{
		VPCWarning( "Unable to get Perforce interface from p4lib.dll." );
		return false;
	}

	// Let the P4 module get its interface to the filesystem - hate this

	// This method is not available in portal2, but is in source2.
	//	p4->SetVerbose( false );
	m_pFilesystemModule = Sys_LoadModule( filesystemdll );
	p4->Connect( Sys_GetFactory( (CSysModule*)m_pFilesystemModule ) );

	return true;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::UnloadPerforceInterface()
{
	if ( p4 )
	{
// TODO: is this necessary? It seems to cause crashes.
//		p4->Shutdown();
	}

	// Unload P4 if it was loaded
	if ( m_pP4Module )
	{	
		Sys_UnloadModule( m_pP4Module );
		m_pP4Module = PLAT_MODULE_INVALID;
	}

	if ( m_pFilesystemModule )
	{
		Sys_UnloadModule( m_pFilesystemModule );
		m_pFilesystemModule = PLAT_MODULE_INVALID;
	}
}


bool VPC_Config_IgnoreOption( const char *pPropertyName )
{
    CUtlStringBuilder *pStrBuf = g_pVPC->GetPropertyValueBuffer();
	g_pVPC->GetScript().ParsePropertyValue( NULL, pStrBuf );
	return true;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::VPCError( const char *pFormat, ... )
{
	va_list		argptr;
	char		msg[MAX_SYSPRINTMSG];
		
	va_start( argptr,pFormat );
	vsprintf( msg, pFormat, argptr );
	va_end( argptr );

	BreakPacifier();

	// since we are going to prefix want caller provided prefixed CR to be handled first to keep message intact
	const char *pMsg = msg;
	while ( *pMsg == '\n' )
	{
		Log_Warning( LOG_VPC, Color( 255, 0, 0, 255 ), "\n" );
		pMsg++;
	}

	// spew in red
	Log_Warning( LOG_VPC, Color( 255, 0, 0, 255 ), "ERROR: %s\n", msg );

	// dump the script stack to assist in user understanding of the include chain
	GetScript().SpewScriptStack( true );

	// stop here if debugging
	DebuggerBreakIfDebugging();

	// do proper shutdown in an error context
	// errors are expected to be fatal by all calling code
	// otherwise it would have been a warning
	Shutdown( true );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::VPCSyntaxError( const char *pFormat, ... )
{
	va_list		argptr;
	char		msg[MAX_SYSPRINTMSG];

	va_start( argptr, pFormat );
	if ( pFormat )
	{
		vsprintf( msg, pFormat, argptr );
	}
	va_end( argptr );

	BreakPacifier();

	if ( pFormat )
	{
		// since we are going to prefix want caller provided prefixed CR to be handled first to keep message intact
		const char *pMsg = msg;
		while ( *pMsg == '\n' )
		{
			Log_Warning( LOG_VPC, Color( 255, 0, 0, 255 ), "\n" );
			pMsg++;
		}

		Log_Warning( LOG_VPC, Color( 255, 0, 0, 255 ), "Bad Syntax: %s\n", pMsg );
	}
	
	// syntax errors are fatal
	VPCError( "Bad Syntax in '%s' line:%d\n", GetScript().GetName(), GetScript().GetLine() );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::VPCWarning( const char *pFormat, ... )
{
	va_list		argptr;
	char		msg[MAX_SYSPRINTMSG];

	va_start( argptr,pFormat );
	vsprintf( msg, pFormat, argptr );
	va_end( argptr );

	if ( m_bIgnoreRedundancyWarning )
	{
		if ( V_stristr( msg, "matches default setting" ) )
			return;
		if ( V_stristr( msg, "already exists in project" ) )
			return;
		if ( V_stristr( msg, "specified multiple times" ) )
			return;
	}

	BreakPacifier();

	// since we are going to prefix want caller provided prefixed CR to be handled first to keep message intact
	const char *pMsg = msg;
	while ( *pMsg == '\n' )
	{
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "\n" );
		pMsg++;
	}

	Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "WARNING: %s\n", pMsg );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::VPCStatus( bool bAlwaysSpew, const char *pFormat, ... )
{
	if ( m_bQuiet || ( !bAlwaysSpew && !m_bVerbose ) )
		return;

	va_list		argptr;
	char		msg[MAX_SYSPRINTMSG];

	va_start( argptr, pFormat );
	vsprintf( msg, pFormat, argptr );
	va_end( argptr );

	BreakPacifier();

	// since we auto suffix CR, prevent dual CR when caller just wants a single CR
	const char *pMsg = msg;
	while ( *pMsg == '\n' )
	{
		Log_Msg( LOG_VPC, "\n" );
		pMsg++;
	}

	if ( pMsg[0] )
	{
		Log_Msg( LOG_VPC, "%s\n", pMsg );
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::VPCStatusWithColor( bool bAlwaysSpew, Color messageColor, const char *pFormat, ... )
{
	if ( m_bQuiet || ( !bAlwaysSpew && !m_bVerbose ) )
		return;

	va_list		argptr;
	char		msg[MAX_SYSPRINTMSG];

	va_start( argptr, pFormat );
	vsprintf( msg, pFormat, argptr );
	va_end( argptr );

	BreakPacifier();

	// since we auto suffix CR, prevent dual CR when caller just wants a single CR
	const char *pMsg = msg;
	while ( *pMsg == '\n' )
	{
		Log_Msg( LOG_VPC, messageColor, "\n" );
		pMsg++;
	}

	if ( pMsg[0] )
	{
		Log_Msg( LOG_VPC, messageColor, "%s\n", pMsg );
	}
}

void CVPC::ClearPacifier()
{
	m_nPacifier = 0;
}

void CVPC::OutputPacifier()
{
	if ( !( m_nPacifier++ % 40 ) && ( m_nPacifier > 1 ) )
	{
		// break rows of pacifiers
		Log_Msg( LOG_VPC, "\n" );
	}

	// Add another dot for the pacifier.
	Log_Msg( LOG_VPC, "." );
}

void CVPC::BreakPacifier()
{
	if ( m_nPacifier )
	{
		Log_Msg( LOG_VPC, "\n" );
		m_nPacifier = 0;
	}
}

int CVPC::GetProjectsInGroup( CUtlVector< projectIndex_t > &projectList, const char *pGroupName )
{
	projectList.RemoveAll();

	// Find the specified group
	groupTagIndex_t groupTagIndex = VPC_Group_FindOrCreateGroupTag( pGroupName, false );

	if ( groupTagIndex != INVALID_INDEX )
	{
		FOR_EACH_VEC( m_GroupTags[groupTagIndex].groups, m )
		{
			FOR_EACH_VEC( m_Groups[m_GroupTags[groupTagIndex].groups[m]].projects, n )
			{
				projectList.AddToTail( m_Groups[m_GroupTags[groupTagIndex].groups[m]].projects[n] );
			}
		}
	}

	return projectList.Count();
}



//-----------------------------------------------------------------------------
// Checks to ensure the bin path is in the same tree as the vpc_scripts
// Returns true if bin path valid
//-----------------------------------------------------------------------------
#if !defined( POSIX )
bool CVPC::CheckBinPath( char *pOutBinPath, int outBinPathSize )
{
	char	szScriptPath[MAX_FIXED_PATH];
	char	szDirectory[MAX_FIXED_PATH];
	char	szLastDirectory[MAX_FIXED_PATH];

	// non destructively determine the vpc_scripts directory
	bool bFound = false;
	szLastDirectory[0] = '\0';
	szScriptPath[0] = '\0';
	V_GetCurrentDirectory( szDirectory, sizeof( szDirectory ) );
	while ( 1 )
	{
		V_ComposeFileName( szDirectory, "vpc_scripts", szScriptPath, sizeof( szScriptPath ) );
		if ( Plat_FileExists( szScriptPath ) )
		{
			bFound = true;
			break;
		}

		// previous dir
        V_ComposeFileName( szDirectory, "..", szScriptPath, sizeof( szScriptPath ) );
		
		char fullPath[MAX_FIXED_PATH];
		if ( _fullpath( fullPath, szScriptPath, sizeof( fullPath ) ) )
		{
			V_strncpy( szDirectory, fullPath, sizeof( szDirectory ) );
		}

		if ( !V_stricmp_fast( szDirectory, szLastDirectory ) )
		{
			// can back up no further
			break;
		}
		V_strncpy( szLastDirectory, szDirectory, sizeof( szLastDirectory ) );
	}

	if ( !bFound )
	{
		VPCError( "Failed to determine source directory from current path. Expecting 'vpc_scripts' in source path." );
	}

	char szSourcePath[MAX_FIXED_PATH];
	V_strncpy( szSourcePath, szDirectory, sizeof( szSourcePath ) );

	// check to ensure that executeable and src directory are in the same tree
	// executeable needs to be tightly bound to its vpc_scripts
	char szModuleBinPath[MAX_FIXED_PATH];
	GetModuleFileName( NULL, szModuleBinPath, sizeof( szModuleBinPath ) );

	// cannot trust output from GetModuleFileName(), occasionally has ./ or ../ screwing up comparisons
	V_RemoveDotSlashes( szModuleBinPath, '\\' );
	V_strlower( szModuleBinPath );
	V_strncpy( pOutBinPath, szModuleBinPath, outBinPathSize );

	// assume that if the user is using softlinks, they have paths right
	if ( V_stristr( szModuleBinPath, "\\softlinks\\" ) )
		return true;

	char *pString = V_stristr( szModuleBinPath, "\\devtools\\bin\\" );
	if ( pString )
	{
		// source dirs should match
		char chSave = *pString;
		*pString = '\0';
		bool bSame = !V_stricmp_fast( szSourcePath, szModuleBinPath );
		*pString = chSave;

		if ( bSame )
		{
			return true;
		}
	}
	else
	{
		VPCError( "Executable not running from 'devtools/bin' but from unexpected directory '%s'", szModuleBinPath );
	}

	// mismatched, wierd bin patch could have been a result of user's environment path
	// use expected source path which is based on user's cwd to get the real bin path
	V_strncpy( pOutBinPath, szSourcePath, outBinPathSize );
#ifdef _WIN64
	V_strncat( pOutBinPath, "\\devtools\\bin\\win64\\vpc.exe", outBinPathSize );
#else
	V_strncat( pOutBinPath, "\\devtools\\bin\\win32\\vpc.exe", outBinPathSize );
#endif

	if ( !Plat_FileExists( pOutBinPath ) )
	{
		VPCError( "Correct executeable missing, should be at '%s'", pOutBinPath );
	}

	// yikes, wrong executeable was started, agreed behavior was to restart based on user's cwd
	// REALLY want users to see this, it indicates a possible hazard of using the wrong vpc
	Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "********************************************************************************\n" );
	Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "Wrong Executable '%s' Running!\nRestarting at '%s'\n", szModuleBinPath, pOutBinPath );
	Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "********************************************************************************\n" );
	
	return false;
}
#endif

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::DetermineSourcePath()
{
	char	szSourcePath[MAX_FIXED_PATH];
	char	szLastDirectory[MAX_FIXED_PATH];

	char szOldPath[MAX_FIXED_PATH];
	V_GetCurrentDirectory( szOldPath, sizeof( szOldPath ) );

	// find vpc_scripts from cwd
	szLastDirectory[0] = '\0';
	bool bFound = false;
	while ( 1 )
	{
		V_GetCurrentDirectory( szSourcePath, sizeof( szSourcePath ) );
		if ( !V_stricmp_fast( szSourcePath, szLastDirectory ) )
		{
			// can back up no further
			break;
		}
		V_strncpy( szLastDirectory, szSourcePath, sizeof( szLastDirectory ) );

		char szTestDir[MAX_FIXED_PATH];
		V_ComposeFileName( szSourcePath, "vpc_scripts", szTestDir, sizeof( szTestDir ) );
		struct _stat statBuf;
		if ( _stat( szTestDir, &statBuf ) != -1 )
		{
			bFound = true;
			break;
		}

		// previous dir
		char szPrevDir[MAX_FIXED_PATH];
		V_ComposeFileName( szSourcePath, "..", szPrevDir, sizeof( szPrevDir ) );
		V_SetCurrentDirectory( szPrevDir );
	}

	if ( !bFound )
	{
		VPCError( "Failed to determine source directory from current path. Expecting 'vpc_scripts' in source path." );
	}

	// Remember the source path and restore the path to where it was.
	m_SourcePath = szSourcePath;
	V_SetCurrentDirectory( szOldPath );

	// emit source path, identifies MANY redundant user problems
	// users can easily run from an unintended place due to botched path, mangled directories, etc
	VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Source Path: %s", m_SourcePath.Get() );
}

//-----------------------------------------------------------------------------
// Sets the working directory to .../vpc_scripts as all scripts are 
// guaranteed relative to the vpc script directory.
//-----------------------------------------------------------------------------
void CVPC::SetDefaultSourcePath()
{
	V_SetCurrentDirectory( m_SourcePath.Get() );
}

void CVPC::LoadVPCCache( const char *szScriptFileName, KeyValues &intoKV )
{
	CFmtStr cacheFileName( "%s." VPC_CACHE_EXTENSION, szScriptFileName );
	intoKV.Clear();

	CUtlBuffer kvBuffer;
	kvBuffer.SetBufferType( true, false );
	if ( !Sys_LoadFileIntoBuffer( cacheFileName.Get(), kvBuffer, true ) )
		return;

	//try to load existing cache to preserve other target platforms. Not a huge deal if it fails though
	if ( !intoKV.LoadFromBuffer( cacheFileName.Get(), kvBuffer ) )
		return;

	if ( intoKV.GetInt( "CacheVersion", 0 ) == VPC_CACHE_VERSION )
		return;

	intoKV.Clear();
	intoKV.SetInt( "CacheVersion", VPC_CACHE_VERSION );
}

void CVPC::SaveVPCCache( const char *szScriptFileName, KeyValues &cacheKV )
{
	CFmtStr cacheFileName( "%s." VPC_CACHE_EXTENSION, szScriptFileName );

	CUtlBuffer kvBuffer;
	kvBuffer.SetBufferType( true, false );
	
	cacheKV.RecursiveSaveToFile( kvBuffer, 0 );
	Sys_WriteFileIfChanged( cacheFileName.Get(), kvBuffer, true );
}

//-----------------------------------------------------------------------------
// Operates quietly, caller decides fate of informative status.
//-----------------------------------------------------------------------------
bool CVPC::IsProjectCurrent( const char *szScriptFileName, CUtlString &projectStatusString )
{
	KeyValues kvCache( "vpc_cache" );
	LoadVPCCache( szScriptFileName, kvCache );

	KeyValues *pKVTargetKey = kvCache.FindKey( GetTargetPlatformName() );
	if ( !pKVTargetKey )
		return false;

	//generally the primary vcxproj/makefile
	const char *szCRCFile = pKVTargetKey->GetString( "CRCFile" );
	
    if ( !szCRCFile || !Sys_Exists( szCRCFile ) )
    {
        return false;
    }

	// check output files for trivial existence
	{
		KeyValues *pKVOutputs = pKVTargetKey->FindKey( "OutputFiles" );
		if ( pKVOutputs )
		{
			for ( KeyValues *pKVIter = pKVOutputs->GetFirstSubKey(); pKVIter; pKVIter = pKVIter->GetNextKey() )
			{
				const char *szOutput = pKVIter->GetString();
				if ( szOutput && szOutput[0] && !Sys_Exists( szOutput ) )
				{
					return false;
				}
			}
		}
	}

	char errorString[1024];
	errorString[0] = '\0';
	bool bCRCValid = VPC_CheckProjectDependencyCRCs( szCRCFile, m_SupplementalCRCString.Get(), errorString, sizeof( errorString ) );

	if ( !m_bVerbose )
	{
		// The detailed CRC error/results string is undesired, it doesn't matter why the CRC failed/succeeded.
		// By popular request, verbosity is used as the enabler, when the CRC yields unexpected results.
		errorString[0] = '\0';
	}

	// start with the detailed informational CRC status
	projectStatusString = errorString;
	if ( !projectStatusString.IsEmpty() )
	{
		// error string has varying contents, no expectation on CR/LF, ensure appended status appears exactly contiguous on next line
		projectStatusString.TrimRight();
		projectStatusString += "\n";
	}

	// The project status string is a terse summary.
	// This is a utility call in varying contexts. The caller decides whether to echo.
	if ( bCRCValid )
	{
		projectStatusString += CFmtStrMax( "Valid: '%s' Passes CRC Checks.", szScriptFileName );
	}
	else
	{
		projectStatusString += CFmtStrMax( "Stale: '%s' Requires Rebuild.", szScriptFileName );
	}

	return bCRCValid;
}

void CVPC::UpdateCacheFile( const char *szScriptFileName )
{
	KeyValues kvCache( "vpc_cache" );

	//try to load existing cache to preserve other target platforms. Not a huge deal if it fails though
	LoadVPCCache( szScriptFileName, kvCache );

	KeyValues *pKVTargetKey = kvCache.FindKey( GetTargetPlatformName(), true );

	//nuke the old values for this target platform
	pKVTargetKey->Clear();

	Assert( m_pProjectGenerator );
	const char *szOutputFileName = m_pProjectGenerator->GetOutputFileName();
	Assert( szOutputFileName );
	
	pKVTargetKey->SetString( "CRCFile", CFmtStr( "%s." VPCCRCCHECK_FILE_EXTENSION, szOutputFileName ) );

	{
		KeyValues *pKVOutputs = pKVTargetKey->CreateKey("OutputFiles");

		int nKeyName = 0;
		pKVOutputs->SetString( CFmtStr( "%d", nKeyName++ ).Get(), szOutputFileName );

		//ancillary files
		//TODO: The project generator should probably control this
		if ( m_bUse2010 && IsConditionalDefined( "GENERATE_MAKEFILE_VCXPROJ" ) )
		{
			// IsProjectCurrent is only called once even though
			// we're generating twice and thus have more files to check,
			// so we special-case here to make sure all files of
			// interest are checked.
			CUtlPathStringHolder extraOutFile( szOutputFileName, ".vcxproj" );
			pKVOutputs->SetString( CFmtStr( "%d", nKeyName++ ).Get(), extraOutFile.Get() );
			extraOutFile.Append( ".filters" );
			pKVOutputs->SetString( CFmtStr( "%d", nKeyName++ ).Get(), extraOutFile.Get() );
		}
		else if ( m_bUse2010 )
		{
			CUtlPathStringHolder extraOutFile( szOutputFileName, ".filters" );
			pKVOutputs->SetString( CFmtStr( "%d", nKeyName++ ).Get(), extraOutFile.Get() );
		}
	}

	SaveVPCCache( szScriptFileName, kvCache );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::SpewUsage( void )
{
	// skip header if user requested specific detail
	bool bNoHeader = 
		m_bSpewPlatforms || 
		m_bSpewGames || 
		m_bSpewProjects ||
		m_bSpewGroups ||
		m_bSpewProperties ||
		m_BuildCommands.Count();

	if ( !bNoHeader )
	{
		Log_Msg( LOG_VPC, "\n" );

		if ( !m_bHelp )
		{
			// terse
			Log_Msg( LOG_VPC, "Type vpc /h for help...\n" );
		}
		else
		{
			// verbose
			Log_Msg( LOG_VPC, "usage: vpc [options] <+/-/*/@project or group>\n");

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Use +/- to add or remove projects or groups.\n");
			Log_Msg( LOG_VPC, "  Use *   to add a project and all projects that depend on it.\n");
			Log_Msg( LOG_VPC, "  Use @   to add a project and all projects that it depends on.\n");
			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Use /h spew final target build set ONLY (no .vcproj created).\n");

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "Examples:\n" );

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Single .vcproj generation:\n" );
			Log_Msg( LOG_VPC, "    vpc +client /hl2     <-- Creates a Win32 .vcproj for the HL2 client.\n" );
			Log_Msg( LOG_VPC, "    vpc +shaderapi /x360 <-- Creates a Xbox360 .vcproj for the shaderapi.\n" );

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Multiple .vcproj generation - Multiple Projects for Games:\n" );
			Log_Msg( LOG_VPC, "    vpc +client /hl2 /tf     <-- Creates ALL the Win32 .vcprojs for the HL2 and TF client.\n" );
			Log_Msg( LOG_VPC, "    vpc +gamedlls /allgames  <-- Creates ALL the Win32 .vcprojs for client and server for all GAMES.\n" );
			Log_Msg( LOG_VPC, "    vpc +tools -tier0 /win32 <-- Creates ALL the Win32 .vcprojs for the tool projects but not the tier0 project.\n" );

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Automatically expand and add projects based on dependencies:\n" );
			Log_Msg( LOG_VPC, "    vpc *tier2 <--- Would expand out to every project that needs tier2. i.e. How do I know what projects are affected for my tier2 change?\n");
			Log_Msg( LOG_VPC, "    vpc @engine <--- Would expand out to every project that engine requires. i.e. What projects might I need to fully debug engine?\n");
			Log_Msg( LOG_VPC, "\n" );

			Log_Msg( LOG_VPC, "  Creating Solutions:\n" );
			Log_Msg( LOG_VPC, "    vpc /mksln foo.sln *tier2 +bar <--- Builds a foo solution of all tier2 consumers and bar. Sets up solution dependencies as required.\n");
			Log_Msg( LOG_VPC, "    vpc /mksln foo.sln @engine +bar <--- Builds a foo solution of engine and all the projects it requires and bar. Sets up solution dependencies as required.\n");
			Log_Msg( LOG_VPC, "    vpc /p4sln checkin.sln 0 <--- Builds a checkin solution with all dependencies based on whatever is in the current p4 client's changelists.\n" );

			Log_Msg( LOG_VPC, "\n" );
			Log_Msg( LOG_VPC, "  Further details can be found on Valve Internal Wiki on VPC.\n" );

			Log_Msg( LOG_VPC, "\n--- OPTIONS ---\n" );
			Log_Msg( LOG_VPC, "[/q]:           Quiet mode (quiet mode is automatically on if the VPC_QUIET environment variable is set)\n" );
			Log_Msg( LOG_VPC, "[/qv]:          Quiet just the CRC valid spew for those projects that are up-to-date.\n" );
			Log_Msg( LOG_VPC, "[/v]:           Verbose\n" );
			Log_Msg( LOG_VPC, "[/f]:           Force rewrite project files, even if they would not change\n" );
			Log_Msg( LOG_VPC, "[/fi]:          Ignore input CRC checks, always consider regenerating projects\n" );
			Log_Msg( LOG_VPC, "[/fc]:          Force build dependency caches\n" );
			Log_Msg( LOG_VPC, "[/dp]:          Decorate project names with platform\n" );
			Log_Msg( LOG_VPC, "[/testmode]:    Override output .vcproj file to be named 'test.vcproj'\n" );
			Log_Msg( LOG_VPC, "[/projsuffix]:  <suffix> - Override output .vcproj file to be named '?????_suffix.vcproj'\n" );
			Log_Msg( LOG_VPC, "[/mirror]:      <path> - Mirror output files to specified path. Used for A:B testing.\n" );
			Log_Msg( LOG_VPC, "[/2015]:        Generate projects and solutions for Visual Studio 2015\n");
			Log_Msg( LOG_VPC, "[/2013]:        Generate projects and solutions for Visual Studio 2013\n" );
			Log_Msg( LOG_VPC, "[/2012]:        Generate projects and solutions for Visual Studio 2012\n" );
			Log_Msg( LOG_VPC, "[/2010]:        Generate projects and solutions for Visual Studio 2010\n" );
			Log_Msg( LOG_VPC, "[/2005]:        Generate projects and solutions for Visual Studio 2005\n" );

			Log_Msg( LOG_VPC, "\n--- Help ---\n" );
			Log_Msg( LOG_VPC, "[/h]:           Help\n" );
			Log_Msg( LOG_VPC, "[/?]:           Help\n" );
			Log_Msg( LOG_VPC, "[/platforms]:   Spew Platforms\n" );
			Log_Msg( LOG_VPC, "[/games]:       Spew Games\n" );
			Log_Msg( LOG_VPC, "[/projects]:    Spew Projects\n" );
			Log_Msg( LOG_VPC, "[/groups]:      Spew Groups\n" );
			Log_Msg( LOG_VPC, "[/properties]:  Spew Properties\n" );

			Log_Msg( LOG_VPC, "\n--- Reserved Conditionals ---\n" );
			Log_Msg( LOG_VPC, "[/profile]:     Set Reserved $PROFILE=1\n" );
			Log_Msg( LOG_VPC, "[/retail]:      Set Reserved $RETAIL=1\n" );
			Log_Msg( LOG_VPC, "[/callcap]:     Set Reserved $CALLCAP=1\n" );
			Log_Msg( LOG_VPC, "[/fastcap]:     Set Reserved $FASTCAP=1\n" );
			Log_Msg( LOG_VPC, "[/memtest]:     Set Reserved $MEMTEST=1\n" );
			Log_Msg( LOG_VPC, "[/nofpo]:       Set Reserved $NOFPO=1\n" );
			Log_Msg( LOG_VPC, "[/lv]:          Set Reserved $LV=1\n" );
			Log_Msg( LOG_VPC, "[/demo]:        Set Reserved $DEMO=1\n" );
			Log_Msg( LOG_VPC, "[/no_steam]:    Set Reserved $NO_STEAM=1\n" );
			Log_Msg( LOG_VPC, "[/no_scaleform]:    Set Reserved $NO_SCALEFORM=1\n" );
			Log_Msg( LOG_VPC, "[/no_ceg]:      Set Reserved $NO_CEG=1\n" );
			Log_Msg( LOG_VPC, "[/upload_ceg]:  Set Reserved $UPLOAD_CEG=1\n" );
			Log_Msg( LOG_VPC, "[/no_qt]:       Set Reserved $ALLOW_QT=0\n" );
			Log_Msg( LOG_VPC, "[/qtdebug]:     Set Reserved $QTDEBUG=1\n" );
			Log_Msg( LOG_VPC, "[/no_schema]:   Set Reserved $ALLOW_SCHEMA=0\n" );
			Log_Msg( LOG_VPC, "[/unity]:	   Set Reserved $ALLOW_UNITY=1\n" );
			Log_Msg( LOG_VPC, "[/forceunity]:  Set Reserved $ALLOW_UNITY=1 and compile writable files in unity files -- needed for buildbot\n" );
		
			Log_Msg( LOG_VPC, "\n--- User Custom Conditionals ---\n" );
			Log_Msg( LOG_VPC, "[/define:xxx]:   Enable a custom conditional $XXX as true to use for quick testing in VPC files.\n" );
			Log_Msg( LOG_VPC, "                 (i.e. /define:FOOBAR, sets $FOOBAR=1, otherwise the default is $FOOBAR=0)\n" );

			Log_Msg( LOG_VPC, "\n--- Solution Generation ---\n" );
			Log_Msg( LOG_VPC, "[/mksln]:        <.sln filename> - make a solution file\n" );
			Log_Msg( LOG_VPC, "[/p4sln]:        <.sln filename> <changelists...> - make a solution file based on\n" );
			Log_Msg( LOG_VPC, "                 the changelist. Changelists can be specific numbers, 0 or \"default\"\n" );
		    Log_Msg( LOG_VPC, "                 for the default changelist, or \"all\" for all active changelists.\n" );
			Log_Msg( LOG_VPC, "[/slnitems]:     <filename> - adds all files listed in <filename> to generated solutions.\n" );
			Log_Msg( LOG_VPC, "[/slnfolder]:    <folder path with search pattern> - Adds a solution folder\n" );
			Log_Msg( LOG_VPC, "                 containing all the files found in the specified folder path\n" );
			Log_Msg( LOG_VPC, "                 that match the search pattern. Searches all the\n" );
			Log_Msg( LOG_VPC, "                 sub-directories of the specified path as well.\n" );
			Log_Msg( LOG_VPC, "                 (eg. /slnfolder D:\\dev\\source2\\main\\src\\public\\*.h will\n" );
			Log_Msg( LOG_VPC, "                 add all the header files located in the src\\public\\ folder\n" );
			Log_Msg( LOG_VPC, "                 and its sub-directories to the solution.\n" );
			Log_Msg( LOG_VPC, "                 The path can be absolute or relative to the src dir. \n" );
			Log_Msg( LOG_VPC, "[/showdeps]:     Show an example dependency chain for each project that depends\n" );
			Log_Msg( LOG_VPC, "                 on your p4 change list(s).  Use with /p4sln.\n" );
			Log_Msg( LOG_VPC, "[/shallowdeps]:  Do not treat .lib files as dependencies. Allows building a solution of only files directly affected by source code changes for compile testing.\n" );
			Log_Msg( LOG_VPC, "[/allprojects]:  Do not restrict dependency and solutions to the everything group, allow all known projects.\n" );

			Log_Msg( LOG_VPC, "\n--- Checking Files ---\n" );
			Log_Msg( LOG_VPC, "[/checkfiles]:         Check for the existence of files in $file commands. For debugging vpc files.\n" );
			Log_Msg( LOG_VPC, "[/nocheckfiles]:       Do not check for the existence of files in $file commands. For debugging vpc files.\n" );
			Log_Msg( LOG_VPC, "[/checkfiles_error]:   Missing files reported as errors.\n" );
			Log_Msg( LOG_VPC, "[/checkfiles_warning]: Missing files reported as warnings.\n" );

			Log_Msg( LOG_VPC, "\n--- Other ---\n" );
			Log_Msg( LOG_VPC, "[/allgames]:     Enable all conditionals in the game group.\n" );
			Log_Msg( LOG_VPC, "[/noallgames]:   Disable all conditionals in the game group.\n" );
			Log_Msg( LOG_VPC, "[/srcctl]:       Enable source control integration.\n" );
			Log_Msg( LOG_VPC, "[/nosrcctl]:     Disable source control integration.\n" );
			Log_Msg( LOG_VPC, "[/novpcgame]:    Xbox Only. Disable reserved vpc macro $VPCGAME and $VPCGAMECAPS.\n" );
			Log_Msg( LOG_VPC, "                 By default if a single game is specified on command line, then that game\n" );
			Log_Msg( LOG_VPC, "                 name will be used as a value for $VPCGAME and $VPCGAMECAPS macros.\n" );
			Log_Msg( LOG_VPC, "[/clangall]:     Emit .BAT files to parse projects with Clang [WIP]\n" );
			Log_Msg( LOG_VPC, "[/unity_suffix]: Add a '_unity' suffix to $UnityProject-enabled vcxproj files\n" );
			
#ifndef DISALLOW_UNITY_FILE_EXCLUSION			
			Log_Msg( LOG_VPC, "[/unity_update]  <unityfilelistpath>:   (Used by ValveVSAddin)\n" );
#endif

//			Log_Msg( LOG_VPC, "[/p4autoadd]:    Automatically add project files to Perforce.\n" );
//			Log_Msg( LOG_VPC, "[/nop4autoadd]:  Don't automatically add project files to Perforce.\n" );
		}
	}

	if ( m_Conditionals.Count() && m_bSpewPlatforms )
	{
		bool bFirstDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_PLATFORM )
				continue;
			if ( !bFirstDefine )
			{
				Log_Msg( LOG_VPC, "\n--- PLATFORMS ---\n" );
				bFirstDefine = true;
			}
			Log_Msg( LOG_VPC, "%s%s\n", m_Conditionals[i]->m_UpperCaseName.String(), m_Conditionals[i]->m_bDefined ? " = 1" : "" );
		}
	}

	if ( m_Conditionals.Count() && m_bSpewGames )
	{
		bool bFirstGame = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_GAME )
				continue;
			if ( !bFirstGame )
			{
				Log_Msg( LOG_VPC, "\n--- GAMES ---\n" );
				bFirstGame = true;
			}
			Log_Msg( LOG_VPC, "%s%s\n", m_Conditionals[i]->m_UpperCaseName.String(), m_Conditionals[i]->m_bDefined ? " = 1" : "" );
		}
	}

	if ( m_Projects.Count() && m_bSpewProjects )
	{
		// spew all sorted projects
		Log_Msg( LOG_VPC, "\n--- PROJECTS ---\n" );
		CUtlRBTree< const char * > sorted( 0, 0, CaselessStringLessThan );
		for ( int i = 0; i < m_Projects.Count(); i++ )
		{
			sorted.Insert( m_Projects[i].name.String() );
		}
		for ( int i = sorted.FirstInorder(); i != sorted.InvalidIndex(); i = sorted.NextInorder( i ) )
		{
			Log_Msg( LOG_VPC, "[+/-] %s\n", sorted[i] );
		}
	}

	if ( g_pVPC->m_GroupTags.Count() && m_bSpewGroups )
	{
		// spew all sorted groups
		Log_Msg( LOG_VPC, "\n--- GROUPS ---\n" );
		CUtlRBTree< const char * > sorted( 0, 0, CaselessStringLessThan );
		for ( int i = 0; i < g_pVPC->m_GroupTags.Count(); i++ )
		{
			if ( !g_pVPC->m_GroupTags[i].bSameAsProject )
			{
				sorted.Insert( g_pVPC->m_GroupTags[i].name.String() );
			}
		}
		for ( int i = sorted.FirstInorder(); i != sorted.InvalidIndex(); i = sorted.NextInorder( i ) )
		{
			Log_Msg( LOG_VPC, "[+/-] %s\n", sorted[i] );
		}
	}

#if 0
#if defined( _WIN32 )
	if ( m_bSpewProperties )
	{
		for ( int i = 0; i < KEYWORD_MAX; i++ )
		{
			VPC_Config_SpewProperties( (configKeyword_e)i );
		}
	}
#endif
#endif

	if ( m_BuildCommands.Count() )
	{
		// spew details about each command
		Log_Msg( LOG_VPC, "\nUser Build Commands:\n" );
		Log_Msg( LOG_VPC, "--------------------\n" );
		for ( int i = 0; i < m_BuildCommands.Count(); i++ )
		{
			Log_Msg( LOG_VPC, "%s\n", m_BuildCommands[i].String() );
			groupTagIndex_t groupTagIndex = VPC_Group_FindOrCreateGroupTag( m_BuildCommands[i].Get()+1, false );
			if ( groupTagIndex == INVALID_INDEX )
			{
				Log_Msg( LOG_VPC, "   ??? (Unknown Group)\n" );
			}
			else
			{
				groupTag_t *pGroupTag = &g_pVPC->m_GroupTags[groupTagIndex];
				for (int j=0; j<pGroupTag->groups.Count(); j++ )
				{
					group_t *pGroup = &m_Groups[pGroupTag->groups[j]];
					for ( int k=0; k<pGroup->projects.Count(); k++ )
					{
						Log_Msg( LOG_VPC, "   %s\n",  m_Projects[pGroup->projects[k]].name.String() );
					}
				}
			}
		}
	
		Log_Msg( LOG_VPC, "\nTarget Projects:\n" );
		Log_Msg( LOG_VPC, "----------------\n" );
		if ( m_TargetProjects.Count() )
		{
			for ( int i=0; i<m_TargetProjects.Count(); i++ )
			{
				Log_Msg( LOG_VPC, "%s\n", m_Projects[m_TargetProjects[i]].name.String() );
			}
		}
		else
		{
			Log_Msg( LOG_VPC, "Empty Set (no output)\n" );
		}

		Log_Msg( LOG_VPC, "\nTarget Games:\n" );
		Log_Msg( LOG_VPC, "-------------\n" );
		bool bHasDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_GAME )
				continue;
			if ( m_Conditionals[i]->m_bDefined )
			{
				Log_Msg( LOG_VPC, "$%s = 1\n", m_Conditionals[i]->m_UpperCaseName.String() );
				bHasDefine = true;
			}
		}
		if ( !bHasDefine )
		{
			Log_Msg( LOG_VPC, "No Game Set!\n" );
		}

		Log_Msg( LOG_VPC, "\nTarget Platforms:\n" );
		Log_Msg( LOG_VPC, "-----------------\n" );
		bHasDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_PLATFORM )
				continue;
			if ( m_Conditionals[i]->m_bDefined )
			{
				Log_Msg( LOG_VPC, "$%s = 1\n", m_Conditionals[i]->m_UpperCaseName.String() );
				bHasDefine = true;
			}
		}
		if ( !bHasDefine )
		{
			Log_Msg( LOG_VPC, "No Platform Set!\n" );
		}

		Log_Msg( LOG_VPC, "\nSystem Conditionals:\n" );
		Log_Msg( LOG_VPC, "---------------------\n" );
		bHasDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_SYSTEM )
				continue;
			if ( m_Conditionals[i]->m_bDefined )
			{
				Log_Msg( LOG_VPC, "$%s = 1\n", m_Conditionals[i]->m_UpperCaseName.String() );
				bHasDefine = true;
			}
		}
		if ( !bHasDefine )
		{
			Log_Msg( LOG_VPC, "No System Defines Set!\n" );
		}

		Log_Msg( LOG_VPC, "\nScript Conditionals:\n" );
		Log_Msg( LOG_VPC, "---------------------\n" );
		bHasDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_SCRIPT )
				continue;
			if ( m_Conditionals[i]->m_bDefined )
			{
				Log_Msg( LOG_VPC, "$%s = 1\n", m_Conditionals[i]->m_UpperCaseName.String() );
				bHasDefine = true;
			}
		}
		if ( !bHasDefine )
		{
			Log_Msg( LOG_VPC, "No Script Defines Set!\n" );
		}

		Log_Msg( LOG_VPC, "\nCustom Conditionals:\n" );
		Log_Msg( LOG_VPC, "---------------------\n" );
		bHasDefine = false;
		for ( int i = 0; i < m_Conditionals.Count(); i++ )
		{
			if ( m_Conditionals[i]->m_Type != CONDITIONAL_CUSTOM )
				continue;
			if ( m_Conditionals[i]->m_bDefined )
			{
				Log_Msg( LOG_VPC, "$%s = 1\n", m_Conditionals[i]->m_UpperCaseName.String() );
				bHasDefine = true;
			}
		}
		if ( !bHasDefine )
		{
			Log_Msg( LOG_VPC, "No Custom Defines Set!\n" );
		}

		Log_Msg( LOG_VPC, "\nMacros:\n" );
		Log_Msg( LOG_VPC, "-------\n" );
		bool bHasMacro = false;
		for ( int nMacroIndex = m_Macros.FirstInorder(); nMacroIndex != m_Macros.InvalidIndex(); nMacroIndex = m_Macros.NextInorder( nMacroIndex ) )
		{
			CMacro *pMacro = m_Macros[nMacroIndex];
			Log_Msg( LOG_VPC, "$%s = %s\n", pMacro->GetName(), pMacro->GetValue() );
			Log_Msg( LOG_VPC, "   Configuration: %s\n", pMacro->IsPropertyMacro() ? pMacro->GetConfigurationName() : "" );
			Log_Msg( LOG_VPC, "   Defined For Compiler: %s\n", pMacro->ShouldDefineInProjectFile() ? "Yes" : "No" );
			Log_Msg( LOG_VPC, "   Created By: %s\n", pMacro->IsSystemMacro() ? "VPC" : "Script" );
			Log_Msg( LOG_VPC, "\n" );

			bHasMacro = true;
		}
		if ( !bHasMacro )
		{
			Log_Msg( LOG_VPC, "No Macros Set!\n" );
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::HandleSingleCommandLineArg( const char *pArg )
{
	if ( ( pArg[0] == '-' ) || ( pArg[0] == '/' ) )
	{
		// skip past arg prefix
		const char *pArgName = pArg+1;

		// check options
		if ( !V_stricmp_fast( pArgName, "h" ) || !V_stricmp_fast( pArgName, "?" ) || !V_stricmp_fast( pArgName, "help" ) )
		{
			m_bHelp = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "v" ) || !V_stricmp_fast( pArgName, "verbose" ) )
		{
			m_bVerbose = true;
		}
		else if ( !V_stricmp_fast( pArgName, "q" ) || !V_stricmp_fast( pArgName, "quiet" ) )
		{
			m_bQuiet = true;
		}
		else if ( !V_stricmp_fast( pArgName, "qv" ) )
		{
			m_bQuietValidSpew = true;
		}
		else if ( !V_stricmp_fast( pArgName, "testmode" ) || !V_stricmp_fast( pArgName, "test" ) )
		{
			m_bTestMode = true;
		}
		else if ( !V_stricmp_fast( pArgName, "showfixedpaths" ) )
		{
			// this a non-exposed option for centric debugging
			m_bShowFixedPaths = true;
		}
		else if ( !V_stricmp_fast( pArgName, "showcaseissues" ) || !V_stricmp_fast( pArgName, "showcase" ) )
		{
			m_bShowCaseIssues = true;
		}
		else if ( !V_stricmp_fast( pArgName, "f" ) || !V_stricmp_fast( pArgName, "force" ) )
		{
			m_bForceGenerate = true;
		}
		else if ( !V_stricmp_fast( pArgName, "fi" ) || !V_stricmp_fast( pArgName, "forceiterate" ) )
		{
			m_bForceIterate = true;
		}
		else if ( !V_stricmp_fast( pArgName, "fc" ) )
		{
			m_bForceRebuildCache = true;
		}
		else if ( !V_stricmp_fast( pArgName, "novpcgame" ) )
		{
			m_bEnableVpcGameMacro = false;
		}
		else if ( !V_stricmp_fast( pArgName, "shallowdeps" ) )
		{
			m_bShallowDepencies = true;
		}
		else if ( !V_stricmp_fast( pArgName, "checkfiles" ) )
		{
			SetConditional( "MISSING_FILE_CHECK", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "nocheckfiles" ) )
		{
			SetConditional( "MISSING_FILE_CHECK", false, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "checkfiles_error" ) )
		{
			SetConditional( "MISSING_FILE_IS_ERROR", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "checkfiles_warning" ) )
		{
			SetConditional( "MISSING_FILE_IS_ERROR", false, CONDITIONAL_SYSTEM );
		}
        else if ( !V_stricmp_fast( pArgName, "disable_per_file_compile_config" ) )
        {
            m_bPerFileCompileConfig = false;
        }
        else if ( !V_stricmp_fast( pArgName, "disable_lib_within_lib" ) )
        {
            m_bAllowLibWithinLib = false;
        }
		else if ( !V_stricmp_fast( pArgName, "dp" ) )
		{
			m_bDecorateProject = true;
			m_ExtraOptionsForCRC.InsertIfNotFound( "/dp" );
		}
		else if ( !V_stricmp( pArgName, "no_scaleform" ) || !V_stricmp( pArgName, "noscaleform") || !V_stricmp( pArgName, "nosf") || !V_stricmp( pArgName, "no_sf") )
		{
			// Disable Scaleform
			SetConditional( "NO_SCALEFORM", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp( pArgName, "no_steam" ) || !V_stricmp( pArgName, "nosteam") )
		{
			// Disable Steam
			SetConditional( "NO_STEAM", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "qt" ) )
		{
			// Enable Qt
			SetConditional( "ALLOW_QT", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "no_qt" ) || !V_stricmp_fast( pArgName, "noqt" ) )
		{
			// Disable Qt
			SetConditional( "ALLOW_QT", false, CONDITIONAL_SYSTEM );		
		}
		else if ( !V_stricmp_fast( pArgName, "schema" ) )
		{
			// Enable Schema
			SetConditional( "ALLOW_SCHEMA", true, CONDITIONAL_SYSTEM );		
		}
		else if ( !V_stricmp_fast( pArgName, "no_schema" ) || !V_stricmp_fast( pArgName, "noschema" ) )
		{
			// Disable Schema
			SetConditional( "ALLOW_SCHEMA", false, CONDITIONAL_SYSTEM );	
		}
		else if ( !V_stricmp_fast( pArgName, "unity" ) )
		{
			// Enable Unity
			SetConditional( "ALLOW_UNITY", true, CONDITIONAL_SYSTEM );		
			// TEMP: until the unity feature is more widely deployed, we turn it on by default but
			//       only for schematized header files (this mirrors the old behaviour). If you
			//       pass '/unity', this turns it on for ALL files:
			m_bUnitySchemaHeadersOnly = false;
			m_ExtraOptionsForCRC.InsertIfNotFound( "/unity" );
		}
		else if ( !V_stricmp_fast( pArgName, "forceunity" ) )
		{
			// Enable Unity on all files, even writable files.
			SetConditional( "ALLOW_UNITY", true, CONDITIONAL_SYSTEM );		
			m_bUnitySchemaHeadersOnly = false;
			m_bUnityOnWritableFiles = true;
			m_ExtraOptionsForCRC.InsertIfNotFound( "/forceunity" );
		}
		else if ( !V_stricmp_fast( pArgName, "no_unity" ) || !V_stricmp_fast( pArgName, "nounity" ) )
		{
			// Disable unity
			SetConditional( "ALLOW_UNITY", false, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "unity_suffix" ) )
		{
			// Add a '_unity' suffix to $UnityProject-enabled vcxproj files:
			m_bAddUnitySuffix = true;
			m_ExtraOptionsForCRC.InsertIfNotFound( "/unity_suffix" );
		}
		else if ( !V_stricmp_fast( pArgName, "clang" ) )
		{
			// Enable Clang
			SetConditional( "ALLOW_CLANG", true, CONDITIONAL_SYSTEM );		
		}
		else if ( !V_stricmp_fast( pArgName, "no_clang" ) || !V_stricmp_fast( pArgName, "noclang" ) )
		{
			// Disable Clang
			SetConditional( "ALLOW_CLANG", false, CONDITIONAL_SYSTEM );		
		}
		else if ( !V_stricmp_fast( pArgName, "genmakeproj" ) )
		{
            m_bGenMakeProj = true;
		}
		else if ( !V_stricmp_fast( pArgName, "clangall" ) )
		{
			m_bEmitClangProject = true;
		}
		else if ( !V_stricmp_fast( pArgName, "dedicated" ) )
		{
			m_bDedicatedBuild = true;
			m_bAppendSrvToDedicated = true;
			m_bUseValveBinDir = true;
		}
		else if ( !V_stricmp_fast( pArgName, "use_valve_bin" ) ) 
		{
			m_bUseValveBinDir = true;
		}
		else if ( !V_stricmp_fast( pArgName, "platforms" ) || !V_stricmp_fast( pArgName, "plats" ) )
		{
			m_bSpewPlatforms = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "games" ) )
		{
			m_bSpewGames = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "projects" ) )
		{
			m_bSpewProjects = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "groups" ) )
		{
			m_bSpewGroups = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "properties" ) )
		{
			m_bSpewProperties = true;
			m_bUsageOnly = true;
		}
		else if ( !V_stricmp_fast( pArgName, "allgames" ) )
		{
			SetupAllGames( true );
		}
		else if ( !V_stricmp_fast( pArgName, "noallgames" ) )
		{
			SetupAllGames( false );
		}
		else if ( !V_stricmp_fast( pArgName, "showdeps" ) )
		{
			m_bShowDeps = true;
		}
		else if ( !V_stricmp_fast( pArgName, "p4autoadd" ) )
		{
			SetConditional( "P4_AUTO_ADD", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "nop4autoadd" ) )
		{
			SetConditional( "P4_AUTO_ADD", false, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "2005" ) || !V_stricmp_fast( pArgName, "2010" ) || !V_stricmp_fast( pArgName, "2012" ) || !V_stricmp_fast( pArgName, "2013" ) || !V_stricmp_fast( pArgName, "2015" ) )
		{
			// User provided CL trumps any pre-set defaults.
			SetConditional( "PREFER_VS2010", !V_stricmp_fast( pArgName, "2010" ), CONDITIONAL_SYSTEM );
			SetConditional( "PREFER_VS2012", !V_stricmp_fast( pArgName, "2012" ), CONDITIONAL_SYSTEM );
			SetConditional( "PREFER_VS2013", !V_stricmp_fast( pArgName, "2013" ), CONDITIONAL_SYSTEM );
			SetConditional( "PREFER_VS2015", !V_stricmp_fast( pArgName, "2015" ), CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "restart" ) || !V_stricmp_fast( pArgName, "noautoargs" ) )
		{
			// quietly consume to prevent confusion as build commands
		}
		else if ( !V_stricmp_fast( pArgName, "nosrcctl" ) )
		{
			// support terser format
			SetConditional( "SOURCECONTROL", false, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "srcctl" ) )
		{
			// support terser format
			SetConditional( "SOURCECONTROL", true, CONDITIONAL_SYSTEM );
		}
		else if ( !V_stricmp_fast( pArgName, "allprojects" ) )
		{
			m_bRestrictProjects = false;
		}
		else if ( !V_stricmp_fast( pArgName, "cert" ) )
		{
			VPCError( "Cannot enable /CERT via command line. CERT as a command line option has been deprecated. Use /RETAIL with a console platform modifier." );
		}
		else if ( char const *pActualDefineName = StringAfterPrefix( pArgName, "define:" ) )
		{
			// Define:<string> is used to explicitly inform VPC that 'string' is a conditional.
			// Conditionals occur in various flavors. User created conditionals can be set with /define:
			conditional_t *pConditional = FindOrCreateConditional( pActualDefineName, false, CONDITIONAL_NULL );
			if ( !pConditional )
			{
				// not a recognized conditional, create a new custom conditional (likely a user's private conditional that just affects their scripts)
				pConditional = FindOrCreateConditional( pActualDefineName, true, CONDITIONAL_CUSTOM );
			}

			// found as a VPC recognized conditional
			SetConditional( pActualDefineName, true, pConditional->m_Type );
		}
		else
		{
			// not a recognized option, assume it's a conditional
			conditional_t *pConditional = FindOrCreateConditional( pArgName, false, CONDITIONAL_NULL );
			if ( !pConditional )
			{
				// not a recognized conditional, assume it's a build command
				int index = m_BuildCommands.AddToTail();
				m_BuildCommands[index] = pArg;
			}
			else
			{
				// found as a VPC recognized conditional
				SetConditional( pArgName, true, pConditional->m_Type );
			}
		}
	}
	else if ( pArg[0] == '+' || pArg[0] == '*' || pArg[0] == '@' )
	{
		// add to build commands
		int index = m_BuildCommands.AddToTail();
		m_BuildCommands[index] = pArg;
	}
}
//-----------------------------------------------------------------------------
// Called when /allgames is passed, also implied by /p4sln
//-----------------------------------------------------------------------------
void CVPC::SetupAllGames( bool bSet )
{
	// shortcut for all games defined
	for ( int j=0; j<m_Conditionals.Count(); j++ )
	{
		if ( m_Conditionals[j]->m_Type == CONDITIONAL_GAME )
		{
			m_Conditionals[j]->m_bDefined = bSet;
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::ParseBuildOptions( int argc, const char **argv )
{
	// parse options
	// prefer +??? or -??? prefix syntax for groups and /??? for options because less confusing for new vpc users
	// for ease we will support -??? prefix syntax for matched options as well
	for ( int i = 1; i < argc; i++ )
	{
		const char *pArg = argv[i];

		if ( !V_stricmp_fast( pArg, "/mksln" ) )
		{
			if ( !m_P4SolutionFilename.IsEmpty() )
			{
				VPCError( "Can't use /mksln with /p4sln." );
			}

			if ( (i+1) >= argc )
			{
				VPCError( "/mksln requires a filename after it." );
			}

			// If the next parameter is a standard + or - or / or * parameter, then we take that to be the name of the solution file.
			// So vpc /mksln +engine would generate engine.sln.
			if ( argv[i+1][0] == '+' || argv[i+1][0] == '-' || argv[i+1][0] == '/' || argv[i+1][0] == '*' || argv[i+1][0] == '@' )
			{
				m_MKSolutionFilename = &argv[i+1][1];
			}
			else
			{
				m_MKSolutionFilename = argv[i+1];
				++i;
			}
		}
		else if ( !V_stricmp_fast( pArg, "/p4sln" ) )
		{
			if ( !m_MKSolutionFilename.IsEmpty() )
			{
				VPCError( "Can't use /mksln with %s.", pArg );
			}

			// Get the solution filename.
			++i;
			if ( i >= argc || argv[i][0] == '+' || argv[i][0] == '-' || argv[i][0] == '/' || argv[i][0] == '*' || argv[i][0] == '@' )
			{
				VPCError( "%s <solution filename> <changelist number> [ [restrict_to_group] ].", pArg );
			}

			m_P4SolutionFilename = argv[i];

			// Get the changelist number.
			while ( 1 )
			{
				++i;

				// No more args?
				if ( i >= argc )
					break;

				// Special syntax for including all changelists.
				if ( !V_stricmp_fast( argv[i], "all" ) )
				{
					m_iP4Changelists.AddToTail( -1 );
					continue;
				}

				// Special syntax for including default changelists.
				if ( !V_stricmp_fast( argv[i], "default" ) )
				{
					m_iP4Changelists.AddToTail( 0 );
					continue;
				}
				
				if ( argv[i][0] < '0' || argv[i][0] > '9' )
				{
					// This arg isn't a changelist number
					--i;
					break;
				}

				// Add the changelist number.
				m_iP4Changelists.AddToTail( atoi( argv[i] ) );
			}

			// Make sure at least one changelist number was specified.
			if ( m_iP4Changelists.Count() == 0 )
			{
				VPCError( "%s <solution filename> <changelist number> [additional changelist numbers] [ [restrict_to_group] ].", pArg );
			}

			// Get the group restriction.
			while ( 1 )
			{
				++i;

				// No more args?
				if ( i >= argc )
					break;

				if ( argv[i][0] != '[' || argv[i][V_strlen( argv[i] ) - 1] != ']' )
				{
					// This arg isn't a group name
					--i;
					break;
				}

				CUtlString groupName = argv[i];
				groupName.TrimLeft( "[" );
				groupName.TrimRight( "]" );

				// Add the restricted group name
				m_P4GroupRestrictions.AddToTail( groupName );
			}

			// /p4sln implies allgames
			SetupAllGames( true );
		}
		else if ( !V_stricmp_fast( pArg, "/slnitems" ) )
		{
			// Get the solution items filename
			++i;
			if ( i >= argc || argv[i][0] == '+' || argv[i][0] == '-' || argv[i][0] == '/' || argv[i][0] == '*' || argv[i][0] == '@' )
			{
				VPCError( "/slnitems <solution items filename>." );
			}

			m_SolutionItemsFilename = argv[i];
		}
		else if ( !V_stricmp_fast( pArg, "/slnfolder" ) )
		{
			if ( (i+1) >= argc )
			{
				VPCError( "/slnfolder <folder path with search pattern>." );
			}

			m_SolutionFolderNames.AddToTail( CUtlString( argv[i+1] ) );
		}
		else if ( !V_stricmp_fast( pArg, "/projsuffix" ) )
		{
			// force a project suffix name, used for A:B comparison runs
			++i;
			if ( i >= argc || argv[i][0] == '+' || argv[i][0] == '-' || argv[i][0] == '/' || argv[i][0] == '*' || argv[i][0] == '@' )
			{
				VPCError( "/projsuffix <suffix>." );
			}

			m_ProjectSuffixString = argv[i];
		}
		else if ( !V_stricmp_fast( pArg, "/mirror" ) )
		{
			// force an output mirror, used for A:B comparison runs
			++i;
			if ( i >= argc || argv[i][0] == '+' || argv[i][0] == '-' || argv[i][0] == '/' || argv[i][0] == '*' || argv[i][0] == '@' )
			{
				VPCError( "/mirror <absolute path>." );
			}

			m_OutputMirrorString = argv[i];
			if ( !m_OutputMirrorString.IsEmpty() && !V_IsAbsolutePath( m_OutputMirrorString.Get() ) )
			{
				VPCError( "/mirror <path> requires an absolute path specification." );
			}
		}
		else if ( !V_stricmp_fast( pArg, "/source_file_config_filter" ) )
		{
			// Get the filter string
			++i;
			if ( i >= argc || argv[i][0] == '+' || argv[i][0] == '-' || argv[i][0] == '/' || argv[i][0] == '*' || argv[i][0] == '@' )
			{
				VPCError( "/source_file_config_filter <filter string>." );
			}

			m_sourceFileConfigFilter = argv[i];
		}
		else
		{
			HandleSingleCommandLineArg( pArg );
		}
	}

	CheckForInstalledXDK();
}

//-----------------------------------------------------------------------------
//	Generate a string supplemental to CRC data, derived from command-line options,
//	which trips conditionals so varying certain command-line options can cause .VCPROJ rebuilds.
//-----------------------------------------------------------------------------
void CVPC::GenerateOptionsCRCString()
{
	m_SupplementalCRCString = "_";
	m_SupplementalCRCString += GetCRCStringFromConditionals();

	for ( int i = 0; i < m_ExtraOptionsForCRC.Count(); i++ )
	{
		if ( !m_ExtraOptionsForCRC[i].IsEmpty() )
		{
			m_SupplementalCRCString += CFmtStr( "_%s_", m_ExtraOptionsForCRC[i].Get() );
		}
	}

	VPCStatus( false, "CRC String: %s\n", m_SupplementalCRCString.String() );
}

//-----------------------------------------------------------------------------
//	Restart self from correct location and re-run. Returns FALSE if not applicable,
//	otherwise TRUE if restart occurred.
//-----------------------------------------------------------------------------
bool CVPC::RestartFromCorrectLocation( bool *pIsChild )
{
#if defined( POSIX )
	return false;
#else

	if ( HasCommandLineParameter( "/norestart" ) || HasCommandLineParameter( "/hacknorestart" ) )
	{
		// Allow the executable to run from somewhere other than the current working directory.
		// This should never be used except for specific cases of extreme hackery.
		return false;
	}

	// recursive restart guard
	// restart is a hidden internal param, always the last argument
	// presence identifies spawned process
	bool bIsRestart = false;
	if ( !V_stricmp_fast( m_ppArgv[m_nArgc-1], "/restart" ) )
	{
		bIsRestart = true;
	}
	*pIsChild = bIsRestart;

	char szBinPath[MAX_FIXED_PATH];
	if ( !CheckBinPath( szBinPath, sizeof( szBinPath ) ) )
	{		
		if ( bIsRestart )
		{
			VPCError( "Cyclical Restart: Tell A Programmer!, Aborting." );
		}

		// replicate arguments, add /restart as a recursion guard for the new process
		const char *newArgs[128];
		if ( m_nArgc >= V_ARRAYSIZE( newArgs ) - 2 )
		{
			VPCError( "Excessive Arguments: Tell A Programmer!, Aborting." ); 
		}
		int i;
		for ( i = 0; i < m_nArgc; i++ )
		{
			newArgs[i] = m_ppArgv[i];
		}
		newArgs[i++] = "/restart";
		newArgs[i++] = NULL;

		// restart using synchronous semantic, async semantic causes wierd hang
		int status = _spawnv( _P_WAIT, szBinPath, newArgs );
		if ( !status )
		{
			// called process exited normally
			return true;
		}
		else if ( status > 0 )
		{
			// called process exited with error, pass it along
			exit( status );
		}

		// called process could not be started
		VPCError( "Restart of '%s' failed\n", szBinPath );
	}

	// process is running from correct location
	return false;
#endif
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::CheckForInstalledXDK()
{
#ifndef POSIX
	if ( !IsPlatformDefined( "X360" ) )
	{
		// caller not doing any 360 work, so ignore
		return;
	}

	// quick and dirty early check for 360 XDK ability
	// can only detect simplistic condition, VPC can't validate a perfect XDK/MSDEV installation
	bool bHasXDK = false;
	const char *pXDK = getenv( "XEDK" );
	if ( pXDK && pXDK[0] )
	{
		// look for expected compiler
		CUtlPathStringHolder fullPath( pXDK );
        fullPath.AppendSlash();
        fullPath.Append( "bin\\win32\\cl.exe" );
		int fileSize = Sys_FileLength( fullPath, false );
		if ( fileSize > 0 )
		{
			bHasXDK = true;
		}	
	}
	if ( !bHasXDK )
	{
		VPCError( "Cannot Build For Xbox 360, XDK is missing or damaged. Remove /x360 from command line." );
	}
#endif
}

void CVPC::CreateVSAddinMetadataString( void )
{
	// Set up a metadata string for the VS add-in, encoding a set of unique identifiers for the associated vcxproj
	m_VSAddinMetadata.Format( "PROJECT.%s.GAME.%s.PLATFORM.%s", g_pVPC->IsTestMode() ? "test" : g_pVPC->GetProjectName(), g_pVPC->GetGameName(), g_pVPC->GetTargetPlatformName() );
}

void CVPC::DecorateProjectName( CUtlString &undecoratedName )
{
	if ( m_bDecorateProject )
	{
		// caller wants decorated project names, so add platform & unity
		const char *pPlatformString = GetMacroValue( "PLATFORM" );
		const char *pUnityString    = IsProjectUsingUnity() ? "UNITY" : "";
		if ( pPlatformString[0] || pUnityString[0] )
		{
			const char *pComma = ( pPlatformString[0] && pUnityString[0] ) ? "," : "";
			undecoratedName.Append( CFmtStr( " (%s%s%s)", pPlatformString, pComma, pUnityString ) );
		}
	}
}

void CVPC::UndecorateProjectName( CUtlString &decoratedName )
{
	// If decorated, it should end with " (<platform><,UNITY>)"
	const char *pLastSpace = V_strrchr( decoratedName.Get(), ' ' );
	const char *pLastParen = V_strrchr( decoratedName.Get(), ')' );
	if ( pLastSpace && ( pLastSpace[1] == '(' ) && pLastParen && ( pLastParen[1] == 0 ) )
	{
		// The parentheses should contain platform and/or unity, separated by a comma
		const char *pSeparators[] = { ",", ")" };
		CSplitString tokens( pLastSpace+2, pSeparators, ARRAYSIZE(pSeparators) );
		for ( int i = 0; i < tokens.Count(); i++ )
		{
			if ( IsPlatformName( tokens[i] ) )
				continue;
			if ( !V_strcmp( tokens[i], "UNITY" ) )
				continue;

			// Nope, the parens must be part of the actual project name
			return;
		}

		// Yep, it's decorated, so strip that part off
		decoratedName = decoratedName.Slice( 0, pLastSpace - decoratedName.Get() );
	}
}

const char *CVPC::CreateGeneratedRootFilePath( CUtlPathStringHolder *pBuf, const char *pFile, const char *pSuffix )
{
    const char *ppStrs[4];
    int pLens[4];

    ppStrs[0] = g_VPCGeneratedFolderName;
    pLens[0] = -1;
    ppStrs[1] = CORRECT_PATH_SEPARATOR_S;
    pLens[1] = 1;
    ppStrs[2] = pFile;
    pLens[2] = -1;
    ppStrs[3] = pSuffix;
    pLens[3] = -1;
    return pBuf->Concat( 4, ppStrs, pLens );
}

const char *CVPC::CreateGeneratedSubdirPath( CUtlPathStringHolder *pBuf, const char *pTopLevelName )
{
    //
    // Create generated file trees in "_vpc_\<TopLevelName>_<ProjectName>_<GameName>\<Platform>\"
    // to avoid filename conflicts and clutter.
    //
    
    const char *ppStrs[10];
    int pLens[10];
    
    ppStrs[0] = g_VPCGeneratedFolderName;
    pLens[0] = -1;
    ppStrs[1] = CORRECT_PATH_SEPARATOR_S;
    pLens[1] = 1;
    ppStrs[2] = pTopLevelName;
    pLens[2] = -1;
    ppStrs[3] = "_";
    pLens[3] = 1;
    ppStrs[4] = GetProjectName();
    pLens[4] = -1;
    const char *pGameName = GetGameName();
    ppStrs[5] = pGameName && pGameName[0] ? "_" : "";
    pLens[5] = -1;
    ppStrs[6] = pGameName;
    pLens[6] = -1;
    ppStrs[7] = CORRECT_PATH_SEPARATOR_S;
    pLens[7] = 1;
    ppStrs[8] = GetTargetPlatformName();
    pLens[8] = -1;
    ppStrs[9] = CORRECT_PATH_SEPARATOR_S;
    pLens[9] = 1;
    return pBuf->Concat( 10, ppStrs, pLens );
}

class COutputFileMacro : public CMacro
{
public:
	COutputFileMacro( void );

	static void ResolveValue( CMacro *pThis )
	{
		if ( !g_pVPC->GetProjectGenerator() )
		{
			g_pVPC->VPCError( "%s used before the project type has been determined", pThis->GetFullName() );
			((COutputFileMacro *)pThis)->m_Value = "";
			return;
		}

		const char *pOutputName = g_pVPC->GetProjectGenerator()->GetOutputFileName();
		if ( ((COutputFileMacro *)pThis)->m_Value != pOutputName )
		{
			((COutputFileMacro *)pThis)->m_Value = pOutputName;
		}
	}
};

bool CVPC::BuildTargetProject( IProjectIterator *pIterator, projectIndex_t projectIndex, script_t *pProjectScript, const char *pGameName )
{
	// evaluate the project's script conditional which determines game/platform
	if ( !EvaluateConditionalExpression( pProjectScript->m_condition.String() ) )
	{
		// conditionals prevent this project from consideration
		return false;
	}

	// set once anything is expected to output
	m_bAnyProjectQualified = true;

	if ( !m_Projects.IsValidIndex( projectIndex ) )
	{
		// unexpected bad project index
		Assert( 0 );
		return false;
	}
	project_t *pProject = &m_Projects[projectIndex];

	// track the internal project name, unaffected by user name mangling
	m_ProjectName = pProject->name.String();
	m_LoadAddressName = pProject->name.String();

	// win32 projects are the most prevalent, so by popular demand they have no decoration
	// all other platforms use their platform name as a suffix
	const char *pPlatformName = NULL;
	if ( !IsPlatformDefined( "win32" ) )
	{
		pPlatformName = GetTargetPlatformName();
	}

	// each vpc script is written with paths relative to their base
	// force each script needs to start relative to their script location
	// this allows vpc to be invoked anywhere, but the groups resolve their projects correctly
	CUtlPathStringHolder scriptPath;
	scriptPath.ComposeFileName( g_pVPC->GetStartDirectory(), pProjectScript->name.String() );
	V_StripFilename( scriptPath.GetForModify() );
	m_ProjectPath = scriptPath;
	V_SetCurrentDirectory( scriptPath );
	
	m_GameName = pGameName;

	//set the unity/nounity state and associated macros
	IsProjectUsingUnity( pProjectScript );
	
	CreateVSAddinMetadataString();
    
	// build it
	char szScriptName[MAX_BASE_FILENAME];
	Sys_StripPath( pProjectScript->name.String(), szScriptName, sizeof( szScriptName ) );
	return pIterator->VisitProject( projectIndex, szScriptName );
}

bool CVPC::BuildDependencyProjects( CUtlVector< CDependency_Project *> &projects )
{
	//back up target projects because I'm not fully aware of what states it could start in
	CUtlVector< projectIndex_t > targetProjectsBackup;
	targetProjectsBackup.AddVectorToTail( m_TargetProjects );

	m_TargetProjects.RemoveAll();

	//translate projects param to m_TargetProjects format
	for ( int i = 0; i < projects.Count(); ++i )
	{
		CDependency_Project *pCurDependency = projects[i];
		m_TargetProjects.AddToTail( pCurDependency->m_iProjectIndex );
	}

	bool bRetVal = BuildTargetProjects();

	//restore target projects to prior state
	m_TargetProjects.RemoveAll();
	m_TargetProjects.AddVectorToTail( targetProjectsBackup );

	return bRetVal;
}

//-----------------------------------------------------------------------------
//	Iterate and build each of the projects. Game projects can themselves be
//	auto-iterated to apply each of their mod variant.
//-----------------------------------------------------------------------------
void CVPC::IterateTargetProjects( CUtlVector<projectIndex_t> &projectList, IProjectIterator *pIterator )
{
	m_bGeneratedProject = false;
	m_bAnyProjectQualified = false;

	if ( !projectList.Count() )
	{
		// nothing to do
		return;
	}

	for ( int nProject = 0; nProject < projectList.Count(); nProject++ )
	{
		project_t *pProject = &m_Projects[projectList[nProject]];

		// each project can have 1 or more scripts that are predicated by game/platform conditionals (i.e. client or server)
		for ( int nScript = 0; nScript < pProject->scripts.Count(); nScript++ )
		{
			script_t *pProjectScript = &pProject->scripts[nScript];

			// occurrence of game condition(s) dictates iteration behavior
			// client/server would have multiple game conditions
			bool bHasGameCondition = g_pVPC->ConditionHasDefinedType( pProjectScript->m_condition.String(), CONDITIONAL_GAME );

			if ( !bHasGameCondition )
			{
				// no game condition
				BuildTargetProject( pIterator, projectList[nProject], pProjectScript, NULL );
			}
			else
			{
				// auto iterate through all defined game conditionals, setting each in turn
				// this provides for building say client for all mod(s) that it can support
				for ( int nTargetGame = 0; nTargetGame < m_Conditionals.Count(); nTargetGame++ )
				{
					if ( m_Conditionals[nTargetGame]->m_Type != CONDITIONAL_GAME || !m_Conditionals[nTargetGame]->m_bDefined )
					{
						// the game conditions must be defined to be considered
						// i.e. the user has specified to build /hl2 /tf2, but not /portal
						continue;
					}

					// only one game condition is active during project generation
					for ( int k = 0; k < m_Conditionals.Count(); k++ )
					{
						// unmark all game conditionals
						if ( m_Conditionals[k]->m_Type == CONDITIONAL_GAME )
						{
							m_Conditionals[k]->m_bGameConditionActive = false;
						}
					}
					m_Conditionals[nTargetGame]->m_bGameConditionActive = true;

					BuildTargetProject( pIterator, projectList[nProject], pProjectScript, m_Conditionals[nTargetGame]->m_Name.String() );
				}
			}	
		}
	}
}

//-----------------------------------------------------------------------------
//	Base implementation is just the crc qualification.
//-----------------------------------------------------------------------------
bool IProjectIterator::VisitProject( projectIndex_t iProject, const char *pScriptPath )
{
	m_CRCCheckStatusSpew.Clear();

	// check project's crc signature
	if ( !g_pVPC->IsForceIterate() && g_pVPC->IsProjectCurrent( pScriptPath, m_CRCCheckStatusSpew ) )
	{
		// valid, does not need to build
		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------
//	Build all the projects in m_targetProjects.
//-----------------------------------------------------------------------------
bool CVPC::BuildTargetProjects()
{
	class CDefaultProjectIterator : public IProjectIterator
	{
	public:
		virtual bool VisitProject( projectIndex_t iProject, const char *pScriptPath ) OVERRIDE
		{
			bool bProjectDirty = IProjectIterator::VisitProject( iProject, pScriptPath );
			if ( !IProjectIterator::m_CRCCheckStatusSpew.IsEmpty() )
			{
				bool bSpewCRCStatus = !g_pVPC->IsQuietValidSpew() || bProjectDirty;
				g_pVPC->VPCStatus( bSpewCRCStatus, "%s", IProjectIterator::m_CRCCheckStatusSpew.Get() );
			}

			if ( !bProjectDirty )
			{
				return false;
			}

			// The project is going to build, users do want to know when the generation happens.
			return g_pVPC->ParseProjectScript( pScriptPath, 0, false, true );
		}
	};

	if ( !m_TargetProjects.Count() )
	{
		VPCError( "No recognized project(s) to build.  Use /h or /projects or /groups to spew more info." );
	}

	// Build the target projects:
	CDefaultProjectIterator iterator;
	IterateTargetProjects( m_TargetProjects, &iterator );

	// Catch user attention to notify lack of any expected output
	// Novice users would not be aware of expected conditionals
	if ( !m_bGeneratedProject && !m_bAnyProjectQualified )
	{
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "----------------------------\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "!!! No Project Generated !!!\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "----------------------------\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "Possibly missing game, platform, or other conditional expected by script.\n" );
		Log_Warning( LOG_VPC, Color( 255, 255, 0, 255 ), "Use /h verify desired target build set.\n" );

		return false;
	}

	return true;
}

//-----------------------------------------------------------------------------
//	Find the project that corresponds to the specified vcproj and setup
//  to build that project.
//-----------------------------------------------------------------------------
void CVPC::FindProjectFromVCPROJ( const char *pScriptNameVCProj, int nMainArgc, const char **ppMainArgv )
{
	// caller is specifying the output vcproj, i.e. via tool shortcut from within MSDEV to re-gen
	// use the vpc standardized output vcproj name to determine re-gen parameters
	// mod and platform will be seperated by '_' after the project name
	// resolve to correct project, best will be longest match, due to project names like foo_? and foo_bar_?
	CUtlString projectName;
	for ( int i = 0; i < m_Projects.Count(); i++ )
	{
		if ( ( StringHasPrefix( pScriptNameVCProj, m_Projects[i].name.Get() ) ) &&
		     ( projectName.Length() < m_Projects[i].name.Length() ) )
		{
			projectName = m_Projects[i].name;
		}
	}
	if ( projectName.Length() == 0 )
	{
		VPCError( "Could not resolve '%s' to any known projects", pScriptNameVCProj );
	}

	// skip past known project prefix and check+remove the extension
	const char *pExt = V_GetFileExtensionSafe( pScriptNameVCProj );

	// vcproj uniquely identifies 2005, vcxproj could be 2010/2012/2013/201x
	bool bUse2005 = !V_stricmp_fast( pExt, "vcproj" );

	CUtlString projectSuffix = CUtlString( pScriptNameVCProj ).StripExtension().Get() + projectName.Length();

	// split the remainder into tokens, separated by '_'
	CSplitString projectTokens( projectSuffix.Get(), "_" );
	CUtlString gameName;
	for ( int i = 0; i < projectTokens.Count(); i++ )
	{
		// The project name may include the platform name ('win64'), 'unity' and the game name (for client/server).
		if ( IsPlatformName( projectTokens[i] ) )
			continue;
		if ( !V_stricmp_fast( projectTokens[i], "unity" ) )
			continue;

		// The game name may include underscores (left4dead2_source2...) so we need to reconstruct it:
		gameName = projectTokens[i];
		for ( int j = i+1; j < projectTokens.Count(); j++ )
		{
			gameName.Append( "_" );
			gameName.Append( projectTokens[j] );
		}

		projectTokens[i] = gameName.GetForModify();
		projectTokens.SetCount( i+1 );
	}

	// build a new commandline, including all original command line arguments except the project filename
	CUtlVector< CUtlString > newArgs;
	for ( int i = 0; i < nMainArgc; i++ )
	{
		newArgs.AddToTail( ppMainArgv[i] );
	}
	newArgs.FindAndRemove( pScriptNameVCProj );

	newArgs.AddToTail( CFmtStr( "+%s", projectName.Get() ).Get() );

	if ( bUse2005 )
	{
		// only 2005 is explicit, VPC will auto choose the 2010/2012/2013/201x based on configuration
		newArgs.AddToTail( "/2005" );
	}
	
	for ( int i = 0; i < projectTokens.Count(); i++ )
	{
		newArgs.AddToTail( CFmtStr( "/%s", projectTokens[i] ).Get() );
	}

	// parse the new command-line
	CUtlVector< const char * > newArgPtrs;
	for ( int i = 0; i < newArgs.Count(); i++ )
	{
		newArgPtrs.AddToTail( newArgs[i].Get() );
	}
	ParseBuildOptions( newArgPtrs.Count(), newArgPtrs.Base() );
}

//-----------------------------------------------------------------------------
// This sets up various defines that are funneled into the .vpc script and the #defines in the engine.
//
// VPC makes a distinction between conditionals and macros (conditionals are just binary on/off things that are used like this:
//      $File "blah.cpp" [$someconditional]
//
// macros are used for substitutions like this:
//		$File "blah.$SOMEMACRO"
//-----------------------------------------------------------------------------
void CVPC::SetMacrosAndConditionals()
{
	// Find the target platform.
	conditional_t *pPlatformConditional = NULL;
	for ( int i = 0; i < m_Conditionals.Count(); i++ )
	{
		if ( m_Conditionals[i]->m_Type == CONDITIONAL_PLATFORM && m_Conditionals[i]->m_bDefined )
		{
			pPlatformConditional = m_Conditionals[i];
			break;
		}
	}

	// Only one platform is allowed to be defined.
	for ( int i = 0; i < m_Conditionals.Count(); i++ )
	{
		if ( m_Conditionals[i] != pPlatformConditional && m_Conditionals[i]->m_Type == CONDITIONAL_PLATFORM && m_Conditionals[i]->m_bDefined )
		{
			// no no no, the user is not allowed to build multiple platforms simultaneously
			// this prior feature really confused/crapped up the code, so absolutely not supporting that
			VPCWarning( "Detected multiple target platforms...Disabling '%s'", m_Conditionals[i]->m_Name.String() );
			m_Conditionals[i]->m_bDefined = false;
		}
	}

	if ( !pPlatformConditional )
	{
		// no user specified platform defined, defaults to primary vpc.exe built platform
#if defined( WIN64 )
		pPlatformConditional = FindOrCreateConditional( "WIN64", false, CONDITIONAL_PLATFORM );
#elif defined( WIN32 )
		pPlatformConditional = FindOrCreateConditional( "WIN32", false, CONDITIONAL_PLATFORM );
#elif defined( OSX64 )
		pPlatformConditional = FindOrCreateConditional( "OSX64", false, CONDITIONAL_PLATFORM );
#elif defined( OSX32 )
		pPlatformConditional = FindOrCreateConditional( "OSX32", false, CONDITIONAL_PLATFORM );
#elif defined( LINUXSTEAMRT64 )
		pPlatformConditional = FindOrCreateConditional( "LINUX64", false, CONDITIONAL_PLATFORM );
#elif defined( LINUXSERVER64 )
		pPlatformConditional = FindOrCreateConditional( "LINUXSERVER64", false, CONDITIONAL_PLATFORM );
#elif defined( LINUXSTEAMRTARM32HF )
		pPlatformConditional = FindOrCreateConditional( "LINUXSTEAMRTARM32HF", false, CONDITIONAL_PLATFORM );
#elif defined( LINUXSTEAMRTARM64HF )
		pPlatformConditional = FindOrCreateConditional( "LINUXSTEAMRTARM64HF", false, CONDITIONAL_PLATFORM );
#else
#error "Unsupported platform."
#endif
		if ( !pPlatformConditional )
		{
			// should never happen, likely a new platform that got setup incorrectly
			VPCError( "Failed to determine target platform." );
		}

		pPlatformConditional->m_bDefined = true;
	}

	CUtlString platformName = pPlatformConditional->m_Name;
	VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Target Platform: %s", platformName.String() );

	// src_main doesn't want this #define because it conflicts with Python's SDK.
	// It really should be called something else that won't conflict with the rest of the world.
	bool bIncludePlatformDefineInProjects = false;
#ifdef STEAM	
	bIncludePlatformDefineInProjects = true;
#endif
		
    SetDynamicMacro( "VPC_OUTPUT_FILE", COutputFileMacro::ResolveValue );

	SetSystemMacro( "PLATFORM", platformName.String(), bIncludePlatformDefineInProjects );

	// create reserved $QUOTE - used for embedding quotes, or use msdev's &quot
	SetSystemMacro( "QUOTE", "\"", false );

	// create reserved $EMPTY - used for purging a value
	SetSystemMacro( "EMPTY", "", false );

    char szCpuCount[10];
    const CPUInformation &CpuInfo = GetCPUInformation();
    V_sprintf_safe( szCpuCount, "%u", CpuInfo.m_nLogicalProcessors );
    SetSystemMacro( "HOST_LOGICAL_CPUS", szCpuCount );

	bool bHaveMakefileTarget = ( VPC_IsPlatformLinux( platformName.String() ) || 
									VPC_IsPlatformAndroid( platformName.String() ) );

    if ( m_bGenMakeProj && 
         !bHaveMakefileTarget )
    {
        VPCError( "/genmakeproj can only be used with make targets like /linuxsteamrt64" );
    }

    // If we're running on Windows we default to generating
    // cross-compile wrapper projects when the selected target
    // platform uses makefiles.
#ifdef WIN32
    if ( bHaveMakefileTarget )
    {
        m_bGenMakeProj = true;
    }
#endif
    if ( m_bGenMakeProj )
    {
        SetConditional( "GENERATE_MAKEFILE_VCXPROJ", true, CONDITIONAL_SYSTEM );

        // We're always using newer solutions and projects in this mode.
        // This won't override a higher version, it just makes sure
        // we get at least VS2010, conforming to other trumps.
        SetConditional( "PREFER_VS2010", true, CONDITIONAL_SYSTEM );
    }

	bool bCrossCompileUsingVisualStudio = bHaveMakefileTarget && m_bGenMakeProj;

	if ( !V_stricmp_fast( platformName.String(), "WIN32" ) ||
		 !V_stricmp_fast( platformName.String(), "WIN64" ) ||
		 !V_stricmp_fast( platformName.String(), "X360" ) ||
		 bCrossCompileUsingVisualStudio )
	{
		if ( PrefersVS2015() )
		{
			m_bUse2015 = true;
		}
		else if ( PrefersVS2013() )
		{
			m_bUse2013 = true;
		}
		else if ( PrefersVS2012() )
		{
			m_bUse2012 = true;
		}
		else if ( PrefersVS2010() )
		{
			m_bUse2010 = true;
		}

		// For backwards compatibility with /define:vs2012 don't set this to false if m_bUse2012 isn't set.
		if ( m_bUse2015 )
		{
			SetConditional( "VS2015", true, CONDITIONAL_SYSTEM );
			m_bUse2010 = true; // Request the 2010 file-format.
		}
		else if ( m_bUse2013 )
		{
			SetConditional( "VS2013", true, CONDITIONAL_SYSTEM );
			m_bUse2010 = true; // Request the 2010 file-format.
		}
		else if ( m_bUse2012 )
		{
			SetConditional( "VS2012", true, CONDITIONAL_SYSTEM );
			m_bUse2010 = true; // Request the 2010 file-format.
		}
		else if ( m_bUse2010 )
		{
			SetConditional( "VS2010", true, CONDITIONAL_SYSTEM );
		}
		else
		{
			SetConditional( "VS2005", true, CONDITIONAL_SYSTEM );
		}
	}
	
	// create and define various other platform related helper conditionals and macros
	if ( !V_stricmp_fast( platformName.String(), "WIN32" ) ||
	     !V_stricmp_fast( platformName.String(), "WIN64" ) )
	{
		if ( !V_stricmp_fast( platformName.String(), "WIN32" ) )
		{
			SetSystemMacro( "PLATSUBDIR", "\\win32", false );
		}
		else
		{
			SetSystemMacro( "PLATSUBDIR", "\\win64", false );
		}

		SetConditional( "WINDOWS", true, CONDITIONAL_SYSTEM );

		SetSystemMacro( "_DLL_EXT", ".dll", true );
		SetSystemMacro( "_IMPLIB_EXT", ".lib", false );
		
		SetSystemMacro( "_DLL_PREFIX", "", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "", false );

		SetSystemMacro( "_STATICLIB_EXT", ".lib", false );
		SetSystemMacro( "_EXE_EXT", ".exe", false );

		SetSystemMacro( "_EXTERNAL_DLL_EXT", ".dll", true );
		SetSystemMacro( "_EXTERNAL_IMPLIB_EXT", ".lib", false );
		SetSystemMacro( "_EXTERNAL_STATICLIB_EXT", ".lib", false );
	}
	else if ( !V_stricmp_fast( platformName.String(), "X360" ) )
	{
		SetSystemMacro( "PLATSUBDIR", "\\x360", false );

		SetSystemMacro( "_DLL_EXT", "_360.dll", true );
		SetSystemMacro( "_IMPLIB_EXT", "_360.lib", false );
		
		SetSystemMacro( "_DLL_PREFIX", "", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "", false );

		SetSystemMacro( "_STATICLIB_EXT", "_360.lib", false );
		SetSystemMacro( "_EXE_EXT", ".exe", false );
	}
	else if ( !V_stricmp_fast( platformName.String(), "PS3" ) )
	{
		SetSystemMacro( "PLATSUBDIR", "\\ps3", false );

		SetSystemMacro( "_DLL_EXT", "_ps3.sprx", true );
		SetSystemMacro( "_IMPLIB_EXT", "_ps3.lib", false );
		
		SetSystemMacro( "_DLL_PREFIX", "", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "", false );

		SetSystemMacro( "_STATICLIB_EXT", "_ps3.lib", false );
		SetSystemMacro( "_EXE_EXT", ".self", false );
	}
	else if ( VPC_IsPlatformLinux( platformName.String() ) ||
				VPC_IsPlatformAndroid( platformName.String() ) )
	{
		if ( VPC_IsPlatformLinux( platformName.String() ) )
		{
			SetConditional( "LINUXALL", true, CONDITIONAL_SYSTEM );
			SetSystemMacro( "LINUX", "1", true );
			SetSystemMacro( "_LINUX", "1", true );
			SetConditional( "LINUX", true, CONDITIONAL_SYSTEM );

			if ( !V_stricmp_fast( platformName.String(), "LINUX64" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\linuxsteamrt64", false );

				SetSystemMacro( "LINUX64", "1", true );
				SetSystemMacro( "LINUXSTEAMRT64", "1", true );
				SetSystemMacro( "_LINUXSTEAMRT64", "1", true );
			}
			else if ( !V_stricmp_fast( platformName.String(), "LINUX32" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\linux32", false );

				SetSystemMacro( "LINUX32", "1", true );
			}
			else if ( !V_stricmp_fast( platformName.String(), "LINUXSTEAMRTARM32HF" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\linuxsteamrtarm32hf", false );

				SetSystemMacro( "LINUXSTEAMRTARM32HF", "1", true );
				SetSystemMacro( "_LINUXSTEAMRTARM32HF", "1", true );
				SetConditional( "ARCH_ARM", true, CONDITIONAL_SYSTEM );
				SetConditional( "LINUXARM", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "LINUXSTEAMRTARM64HF" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\linuxsteamrtarm64hf", false );

				SetSystemMacro( "LINUXSTEAMRTARM64HF", "1", true );
				SetSystemMacro( "_LINUXSTEAMRTARM64HF", "1", true );
				SetConditional( "ARCH_ARM", true, CONDITIONAL_SYSTEM );
				SetConditional( "LINUXARM", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "LINUXSERVER64" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\linuxserver64", false );

				SetSystemMacro( "LINUXSERVER64", "1", true );
				SetSystemMacro( "_LINUXSERVER64", "1", true );
			}
			else
			{
				UNREACHABLE();
			}
		}
		else if ( VPC_IsPlatformAndroid( platformName.String() ) )
		{
			SetConditional( "ANDROIDALL", true, CONDITIONAL_SYSTEM );

			if ( !V_stricmp_fast( platformName.String(), "ANDROIDARM32" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidarm32", false );

				SetSystemMacro( "ANDROIDARM32", "1", true );
				SetSystemMacro( "_ANDROIDARM32", "1", true );
				SetConditional( "ANDROIDARMALL", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "ANDROIDARM64" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidarm64", false );

				SetSystemMacro( "ANDROIDARM64", "1", true );
				SetSystemMacro( "_ANDROIDARM64", "1", true );
				SetConditional( "ANDROIDARMALL", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "ANDROIDMIPS32" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidmips32", false );

				SetSystemMacro( "ANDROIDMIPS32", "1", true );
				SetSystemMacro( "_ANDROIDMIPS32", "1", true );
				SetConditional( "ANDROIDMIPSALL", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "ANDROIDMIPS64" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidmips64", false );

				SetSystemMacro( "ANDROIDMIPS64", "1", true );
				SetSystemMacro( "_ANDROIDMIPS64", "1", true );
				SetConditional( "ANDROIDMIPSALL", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "ANDROIDX8632" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidx8632", false );

				SetSystemMacro( "ANDROIDX8632", "1", true );
				SetSystemMacro( "_ANDROIDX8632", "1", true );
				SetConditional( "ANDROIDX86ALL", true, CONDITIONAL_SYSTEM );
			}
			else if ( !V_stricmp_fast( platformName.String(), "ANDROIDX8664" ) )
			{
				SetSystemMacro( "PLATSUBDIR", "\\androidx8664", false );

				SetSystemMacro( "ANDROIDX8664", "1", true );
				SetSystemMacro( "_ANDROIDX8664", "1", true );
				SetConditional( "ANDROIDX86ALL", true, CONDITIONAL_SYSTEM );
			}
			else
			{
				UNREACHABLE();
			}
		}

		if ( m_bDedicatedBuild )
		{
			SetConditional( "DEDICATED", true, CONDITIONAL_SYSTEM );
		}

		SetConditional( "POSIX", true, CONDITIONAL_SYSTEM );
		
		SetSystemMacro( "POSIX", "1", true );
		SetSystemMacro( "_POSIX", "1", true );
		
		if ( m_bAppendSrvToDedicated )
		{
			SetSystemMacro( "_DLL_EXT", ".so", true );
			SetSystemMacro( "_IMPLIB_EXT", ".so", false );
			SetSystemMacro( "_STATICLIB_EXT", ".a", false );

			// Extensions for external dependencies like libsteam_api.so (not libsteam_api_ds.so).
			// VPC_Keyword_Folder in projectscript.cpp will check for ImpLibExternal or LibExternal and
			// use these prefixes instead of _ds.so if they exist.
			SetSystemMacro( "_EXTERNAL_DLL_EXT", ".so", true );
			SetSystemMacro( "_EXTERNAL_IMPLIB_EXT", ".so", false );
			SetSystemMacro( "_EXTERNAL_STATICLIB_EXT", ".a", false );
		}
		else
		{
			SetSystemMacro( "_DLL_EXT", "_client.so", true );
			SetSystemMacro( "_IMPLIB_EXT", "_client.so", false );
			SetSystemMacro( "_STATICLIB_EXT", "_client.a", false );

			SetSystemMacro( "_EXTERNAL_DLL_EXT", ".so", true );
			SetSystemMacro( "_EXTERNAL_IMPLIB_EXT", ".so", false );
			SetSystemMacro( "_EXTERNAL_STATICLIB_EXT", ".a", false );
		}

		SetSystemMacro( "_DLL_PREFIX", "lib", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "lib", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "lib", false );
		SetSystemMacro( "_EXE_EXT", "", false );
		SetSystemMacro( "_SYM_EXT", ".dbg", false );

		SetConditional( "GL", true, CONDITIONAL_SYSTEM );
	}
	else if ( !V_stricmp_fast( platformName.String(), "OSX32" ) ||
	          !V_stricmp_fast( platformName.String(), "OSX64" ) )
	{
		if ( !V_stricmp_fast( platformName.String(), "OSX32" ) )
		{
			SetSystemMacro( "PLATSUBDIR", "\\osx32", false );
		}
		else
		{
			SetSystemMacro( "PLATSUBDIR", "\\osx64", false );
		}

		SetConditional( "OSXALL", true, CONDITIONAL_SYSTEM );

		if ( m_bDedicatedBuild )
		{
			SetConditional( "DEDICATED", true, CONDITIONAL_SYSTEM );
		}

		SetConditional( "POSIX", true, CONDITIONAL_SYSTEM );
		SetSystemMacro( "_POSIX", "1", true );

		SetSystemMacro( "_DLL_EXT", ".dylib", true );
		SetSystemMacro( "_IMPLIB_EXT", ".dylib", false );

		SetSystemMacro( "_DLL_PREFIX", "lib", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "lib", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "lib", false );

		SetSystemMacro( "_STATICLIB_EXT", ".a", false );
		SetSystemMacro( "_EXE_EXT", "", false );
		SetSystemMacro( "_SYM_EXT", ".dSYM", false );

		SetSystemMacro( "_EXTERNAL_DLL_EXT", ".dylib", true );
		SetSystemMacro( "_EXTERNAL_IMPLIB_EXT", ".dylib", false );
		SetSystemMacro( "_EXTERNAL_STATICLIB_EXT", ".a", false );

		// Mac defaults to GL on
		SetConditional( "GL", true, CONDITIONAL_SYSTEM );
	}
	else if ( !V_stricmp_fast( platformName.String(), "IOS" ) )
	{
		SetConditional( "OSXALL", true, CONDITIONAL_SYSTEM );

		if ( m_bDedicatedBuild )
		{
			SetConditional( "DEDICATED", true, CONDITIONAL_SYSTEM );
		}

		SetConditional( "POSIX", true, CONDITIONAL_SYSTEM );
		SetSystemMacro( "_POSIX", "1", true );

		SetConditional( "IOS", true, CONDITIONAL_SYSTEM );
		SetSystemMacro( "_IOS", "1", true );
		SetSystemMacro( "IOS", "1", true );

		SetSystemMacro( "_DLL_EXT", "_ios.dylib", true );
		SetSystemMacro( "_IMPLIB_EXT", "_ios.dylib", false );
		
		SetSystemMacro( "_DLL_PREFIX", "lib", true );
		SetSystemMacro( "_IMPLIB_PREFIX", "lib", false );
		SetSystemMacro( "_IMPLIB_DLL_PREFIX", "lib", false );
		
		SetSystemMacro( "_STATICLIB_EXT", "_ios.a", false );
		SetSystemMacro( "_EXE_EXT", "", false );

		SetSystemMacro( "_EXTERNAL_DLL_EXT", "_ios.dylib", true );
		SetSystemMacro( "_EXTERNAL_IMPLIB_EXT", "_ios.dylib", false );
		SetSystemMacro( "_EXTERNAL_STATICLIB_EXT", "_ios.a", false );
	}
	else
	{
		UNREACHABLE();
	}

    // Define conditionals for the host platform to allow
    // specializing behavior for cross-compilation situations
    // where the host does not match the target and any
    // tool used during the build must select a version based
    // on the host and not the target.
	SetDynamicMacro( "HOST_VPC_EXE", CHostVPCMacro::ResolveHostVPCMacro );
#if defined( WIN64 )
    SetConditional( "HOST_WINDOWS", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_WIN64", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\win64", false );
    SetSystemMacro( "HOST_EXE_EXT", ".exe", false );
#elif defined( WIN32 )
    SetConditional( "HOST_WINDOWS", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_WIN32", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\win32", false );
    SetSystemMacro( "HOST_EXE_EXT", ".exe", false );
#elif defined( OSX64 )
    SetConditional( "HOST_OSXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_OSX64", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\osx64", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( OSX32 )
    SetConditional( "HOST_OSXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_OSX32", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\osx32", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( LINUX )
    SetConditional( "HOST_LINUXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUX", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUX64", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\linux", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( LINUXSTEAMRT64 )
    SetConditional( "HOST_LINUXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUXSTEAMRT64", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\linuxsteamrt64", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( LINUXSERVER64 )
    SetConditional( "HOST_LINUXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUXSERVER64", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\linuxserver64", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( LINUXSTEAMRTARM32HF )
    SetConditional( "HOST_LINUXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUXSTEAMRTARM32HF", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\linuxsteamrtarm32hf", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#elif defined( LINUXSTEAMRTARM64HF )
    SetConditional( "HOST_LINUXALL", true, CONDITIONAL_SYSTEM );
    SetConditional( "HOST_LINUXSTEAMRTARM64HF", true, CONDITIONAL_SYSTEM );
    SetSystemMacro( "HOST_PLATSUBDIR", "\\linuxsteamrtarm64hf", false );
    SetSystemMacro( "HOST_EXE_EXT", "", false );
#else
#error "Unsupported host platform."
#endif

	// CERT has been decided to be a platform permutation of RETAIL.
	if ( IsConditionalDefined( "RETAIL" ) && ( IsPlatformDefined( "X360" ) || ( IsPlatformDefined( "PS3" ) ) ) )
	{
		// CERT is a restricted console RETAIL concept, with publisher dictated rules, there is no CERT process for non-console platforms.
		SetConditional( "CERT", true, CONDITIONAL_SYSTEM );
	}

	// Set VPCGAME macro based on target game
	// NOTE: This is broken, and is not compatible with /allgames.
	// only the 360 is using this to sign all the DLLs to a specific xlast
	// it basically breaks the win32 crc checks causing unnecessary rebuilds as it encodes the CL game specification into projects crc
	// i.e. it encodes literally /allgames or /gamefoo regardless of a project's game dependency (as opposed to the precise iterated game or an empty string)
	if ( m_bEnableVpcGameMacro )
	{
		int nGameDefineIndex = -1;
		for ( int iOtherGameDefine = 0; iOtherGameDefine < m_Conditionals.Count(); ++ iOtherGameDefine )
		{
			if ( m_Conditionals[iOtherGameDefine]->m_Type == CONDITIONAL_GAME &&
				m_Conditionals[iOtherGameDefine]->m_bDefined )
			{
				if ( nGameDefineIndex == -1 )
				{
					nGameDefineIndex = iOtherGameDefine;
				}
				else
				{
					// uh-oh, multiple games defined for target build
					// can't set VPCGAME accurately
					nGameDefineIndex = -2;	
				}
			}
		}
		
		SetSystemMacro( "VPCGAME", ( nGameDefineIndex >= 0 ) ? m_Conditionals[nGameDefineIndex]->m_Name.Get() : "valve", true );
		SetSystemMacro( "VPCGAMECAPS", ( nGameDefineIndex >= 0 ) ? m_Conditionals[nGameDefineIndex]->m_UpperCaseName.Get() : "VALVE", true );

		// force this into additional CRC string
		// THIS IS WRONG. It cannot be done once.
		// The /allgames specification has not been resolved until the build iteration happens. That's when the CRC string should be updated.
		m_ExtraOptionsForCRC.InsertIfNotFound( CFmtStr( "/vpcgame:%s", GetMacroValue( "VPCGAME" ) ).Get() );
	}
}

//-----------------------------------------------------------------------------
// Checks for command line /params ( +/- used for projects, so ICommandLine() not suitable)
//-----------------------------------------------------------------------------
bool CVPC::HasCommandLineParameter( const char *pParamName )
{
	for ( int i=1; i < m_nArgc; i++ )
	{
		if ( !V_stricmp_fast( m_ppArgv[i], pParamName ) )
			return true;
	}
	return false;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool CVPC::HasP4SLNCommand()
{
	return HasCommandLineParameter( "/p4sln" );
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool CVPC::HandleP4SLN( IBaseSolutionGenerator *pSolutionGenerator )
{
#ifdef WIN32
	// If they want to generate a solution based on a Perforce changelist, adjust m_targetProjects and set it up like /mksln had been passed in.
	if ( m_iP4Changelists.Count() == 0 )
		return false;

	if ( !VPC_AreProjectDependenciesSupportedForThisTargetPlatform() )
		VPCError( "P4SLN not supported for %s yet!", g_pVPC->GetTargetPlatformName() );

	if ( !pSolutionGenerator )
		VPCError( "No solution generator exists for this platform." );

	// Figure out where to put the solution file.
	CUtlPathStringHolder fullSolutionPath;
	if ( V_IsAbsolutePath( m_P4SolutionFilename.Get() ) )
	{
		fullSolutionPath.Set( m_P4SolutionFilename.Get() );
	}
	else
	{
		fullSolutionPath.ComposeFileName( g_pVPC->GetStartDirectory(), m_P4SolutionFilename.Get() );
	}

	CProjectDependencyGraph dependencyGraph;
	GenerateSolutionForPerforceChangelist( dependencyGraph, m_iP4Changelists, pSolutionGenerator, fullSolutionPath );

	return true;
#else
	return false;
#endif
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::HandleMKSLN( IBaseSolutionGenerator *pSolutionGenerator,
                        IBaseSolutionGenerator *pSolutionGenerator2,
                        CProjectDependencyGraph &dependencyGraph )
{
	if ( m_MKSolutionFilename.IsEmpty() )
    {
        if ( !V_stricmp_fast( g_pVPC->GetTargetPlatformName(), "OSX32" ) ||
             !V_stricmp_fast( g_pVPC->GetTargetPlatformName(), "OSX64" ) )
        {
            VPCError( "MKSLN required for Xcode targets" );
        }
		return;
    }

	if ( !VPC_AreProjectDependenciesSupportedForThisTargetPlatform() )
		VPCError( "MKSLN not supported for %s yet!", g_pVPC->GetTargetPlatformName() );

	if ( !pSolutionGenerator )
		VPCError( "No solution generator exists for this platform." );

	// can be called on behalf of /mksln (and thus have dependencies) or /p4sln (and need to create them based on CL #)
	if ( !dependencyGraph.HasGeneratedDependencies() )
	{
		// mksln is based on just the CL specified projects
		dependencyGraph.BuildProjectDependencies( 0 );
	}
	
	// GenerateBuildSet basically generates what we want, except it uses projectIndex_t's, meaning that
	// we don't know what subset of games we should use until we've called VPC_IterateTargetProjects.
	CUtlVector<CDependency_Project*> referencedProjects;
	dependencyGraph.TranslateProjectIndicesToDependencyProjects( m_TargetProjects, referencedProjects );

	// Generate a solution file.
	CUtlPathStringHolder fullSolutionPath;
	if ( V_IsAbsolutePath( m_MKSolutionFilename.Get() ) )
	{
		fullSolutionPath.Set( m_MKSolutionFilename.Get() );
	}
	else
	{
        fullSolutionPath.ComposeFileName( g_pVPC->GetStartDirectory(), m_MKSolutionFilename.Get() );
	}

	//strip off any specified extension and let the generators append their own
	fullSolutionPath.StripExtension();

	pSolutionGenerator->GenerateSolutionFile( fullSolutionPath, referencedProjects );
    
    if ( pSolutionGenerator2 )
    {
        pSolutionGenerator2->GenerateSolutionFile( fullSolutionPath, referencedProjects );
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CVPC::DetermineSolutionGenerator()
{
	extern IBaseSolutionGenerator	*GetSolutionGenerator_Win32();
	extern IBaseSolutionGenerator	*GetMakefileSolutionGenerator();
	extern IBaseSolutionGenerator	*GetXcodeSolutionGenerator();

	bool bIsLinuxPlatform = IsConditionalDefined( "LINUXALL" );
	bool bIsOSXPlatform = IsConditionalDefined( "OSXALL" );
	bool bIsAndroidPlatform = IsConditionalDefined( "ANDROIDALL" );

	// Under Windows we have the ability to generate makefiles so if they specified a linux config,
	// or if they're building the (non-SRCDS) dedicated server, then use the makefile generator
	bool bUseMakefile = bIsLinuxPlatform || bIsAndroidPlatform || bIsOSXPlatform || IsConditionalDefined( "DEDICATED" );
	bool bUseXcode = false; //bIsOSXPlatform;


	if ( bUseMakefile )
	{
		VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Using Makefile generator." );

		m_pSolutionGenerator = GetMakefileSolutionGenerator();
        
		if ( IsConditionalDefined( "GENERATE_MAKEFILE_VCXPROJ" ) )
        {
			const char *pVSName = "2010";
			if ( m_bUse2015 )
				pVSName = "2015";
			else if ( m_bUse2013 )
				pVSName = "2013";
			else if ( m_bUse2012 )
				pVSName = "2012";

            VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating Makefile for Visual Studio %s", pVSName );
			m_pSolutionGenerator2 = GetSolutionGenerator_Win32();
        }
	}
	else if ( bUseXcode )
	{
		VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Using Xcode generator." );

		m_pSolutionGenerator = GetXcodeSolutionGenerator();
		m_bForceIterate = true;
	}
	else
	{
		if ( IsPlatformDefined( "PS3" ) )
		{
			VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for PS3." );

 			m_pSolutionGenerator = GetSolutionGenerator_Win32();
		}
		else if ( IsPlatformDefined( "X360" ) )
		{
			if ( m_bUse2010 )
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2010." );
			}
			else
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2005." );
			}
 			m_pSolutionGenerator = GetSolutionGenerator_Win32();
		}
		else
		{
			if ( m_bUse2015 )
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2015." );
			}
			else if ( m_bUse2013 )
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2013." );
			}
			else if ( m_bUse2012 )
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2012." );
			}
			else if ( m_bUse2010 )
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2010." );
			}
			else
			{
				VPCStatusWithColor( true, Color( 0, 255, 255, 255 ), "Generating for Visual Studio 2005." );
			}
 			m_pSolutionGenerator = GetSolutionGenerator_Win32();
		}

		VPCStatus( true, "\n" );
	}
}

void CVPC::DetermineProjectGenerator()
{
	if ( m_pProjectGenerator )
		return; //already picked one for this project!

	extern IBaseProjectGenerator	*GetWin32ProjectGenerator();
	extern IBaseProjectGenerator	*GetWin32ProjectGenerator_2010();
	extern IBaseProjectGenerator	*GetPS3ProjectGenerator();
	extern IBaseProjectGenerator	*GetXbox360ProjectGenerator();
	extern IBaseProjectGenerator	*GetXbox360ProjectGenerator_2010();
	extern IBaseProjectGenerator	*GetMakefileProjectGenerator();
	extern IBaseProjectGenerator	*GetXcodeProjectGenerator();
	extern IBaseProjectGenerator	*GetAndroidProjectGenerator();
	extern IVCProjWriter			*GetWin32ProjectGenerator_VCProjWriter_2010();

	bool bIsLinuxPlatform = IsConditionalDefined( "LINUXALL" );
	bool bIsOSXPlatform = IsConditionalDefined( "OSXALL" );
	bool bIsAndroidPlatform = IsConditionalDefined( "ANDROIDALL" );
	bool bIsAndroidProject = IsConditionalDefined( "ANDROIDPROJECT" ); //android-specific project template, not just a dll/exe/lib compiled for android platform

	// Under Windows we have the ability to generate makefiles so if they specified a linux config,
	// or if they're building the (non-SRCDS) dedicated server, then use the makefile generator
	bool bUseAndroid = bIsAndroidProject && bIsAndroidPlatform;
	bool bUseMakefile = (bIsLinuxPlatform || bIsAndroidPlatform || bIsOSXPlatform /* || IsConditionalDefined( "DEDICATED" )*/) && !bUseAndroid;
	bool bUseXcode = false; //bIsOSXPlatform;
	

	if ( bUseMakefile )
	{
		m_pProjectGenerator = GetMakefileProjectGenerator();

        // We partially support per-file compile settings in
        // makefiles but many things don't work (everything
        // except defines and includes) so disallow it.

		//TODO: Allow per-file compiler config on makefiles. Is this the right decision?
        m_bPerFileCompileConfig = true;

        // We do not support lib-within-lib for makefiles.
        m_bAllowLibWithinLib = false;
	}
	else if ( bUseXcode )
	{
		m_pProjectGenerator = GetXcodeProjectGenerator();
        // We do not support any kind of per-file
        // compile options for Xcode projects.
        m_bPerFileCompileConfig = false;
        // We do not support lib-within-lib for Xcode.
        m_bAllowLibWithinLib = false;
	}
	else if ( bUseAndroid )
	{
		m_pProjectGenerator = GetAndroidProjectGenerator();
		// We do not support any kind of per-file
        // compile options because we leverage ANT to build android projects.
		m_bPerFileCompileConfig = false;
        // I don't even know what lib within a lib would look like for android yet, assuming it's just as bad as a generic binary
        m_bAllowLibWithinLib = false;
	}
	else
	{
        // MSVC does support lib-within-lib but we want to
        // direct people towards the cross-platform $LibDependsOn
        // feature so disallow lib containment.
        m_bAllowLibWithinLib = false;

		if ( IsPlatformDefined( "PS3" ) )
		{
			m_pProjectGenerator = GetPS3ProjectGenerator();
		}
		else if ( IsPlatformDefined( "X360" ) )
		{
			if ( m_bUse2010 )
			{
				m_pProjectGenerator = GetXbox360ProjectGenerator_2010();
			}
			else
			{
				m_pProjectGenerator = GetXbox360ProjectGenerator();
			}
		}
		else
		{
			if ( m_bUse2015 )
			{
				m_pProjectGenerator = GetWin32ProjectGenerator_2010();
			}
			else if ( m_bUse2013 )
			{
				m_pProjectGenerator = GetWin32ProjectGenerator_2010();
			}
			else if ( m_bUse2012 )
			{
				m_pProjectGenerator = GetWin32ProjectGenerator_2010();
			}
			else if ( m_bUse2010 )
			{
				m_pProjectGenerator = GetWin32ProjectGenerator_2010();
			}
			else
			{
				m_pProjectGenerator = GetWin32ProjectGenerator();
			}
		}
	}
	
	m_pProjectGenerator->StartProject();
	if ( m_pDependencyProject )
	{
		m_pDependencyProject->m_pProjectGenerator = m_pProjectGenerator;
	}
}

//-----------------------------------------------------------------------------
// Since Steam's VPC builds tier0 and vstdlib directly in, Steam uses vpc.exe as the CRC checker.
// Source uses vpccrccheck.exe to do this.
//-----------------------------------------------------------------------------
void CVPC::InProcessCRCCheck()
{
	for ( int i = 1; i<m_nArgc; i++ )
	{
		if ( !V_stricmp_fast( m_ppArgv[i], "-crc" ) || !V_stricmp_fast( m_ppArgv[i], "-crc2" ) )
		{
			// caller wants the crc check only
			int ret = VPC_CommandLineCRCChecks( m_nArgc, (char **)m_ppArgv );
			exit( ret );
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
const char *CVPC::BuildTempGroupScript( const char *pVPCScriptName )
{
	CUtlPathStringHolder projectName( V_UnqualifiedFileName( pVPCScriptName ) );
    projectName.StripExtension();

	char szCurrentDirectory[MAX_FIXED_PATH];
	V_GetCurrentDirectory( szCurrentDirectory, sizeof( szCurrentDirectory ) );

	// caller is specifying an explicit VPC, i.e. not a project from the default group
	// create a temporary group file that mimics a VGC, that points to the current dir's VPC
	char tmpName[20];
	strcpy( tmpName, "vpcXXXXXX" );
	if ( !_mktemp( tmpName ) )
	{
		VPCError( "Could not generate temp name. Tell a Programmer.\n" );
	}

	CUtlPathStringHolder tempGroupScriptFilename( tmpName, "vgc.tmp" );
	m_TempGroupScriptFilename.ComposeFileName( szCurrentDirectory, tempGroupScriptFilename );

	// build the temp group script
	FILE *fp = fopen( m_TempGroupScriptFilename.Get(), "w+t" );
	if ( !fp )
	{
		VPCError( "Could not open temp file '%s'. Tell a Programmer.\n", m_TempGroupScriptFilename.Get() );
	}

	CUtlPathStringHolder vpcScriptFilename;
	vpcScriptFilename.ComposeFileName( szCurrentDirectory, pVPCScriptName );

	// the actual vpc must be relative to the source path
	const char *pVPCFilename = StringAfterPrefix( vpcScriptFilename, m_SourcePath.Get() );
	if ( !pVPCFilename )
	{
		VPCError( "Script %s is not in source path %s\n", vpcScriptFilename.Get(), m_SourcePath.Get() );
	}

	if ( pVPCFilename[0] == '\\' )
	{
		pVPCFilename++;
	}

	fprintf( fp, "$Include \"vpc_scripts\\features.vgc\"\n" );
	fprintf( fp, "$Project \"%s\"\n", projectName.Get() );
	fprintf( fp, "{\n" );
	fprintf( fp, "\"%s\"\n", pVPCFilename );
	fprintf( fp, "}\n" );
	fclose( fp );

	// fake a build command
    CUtlStringHolder<100> buildCommand( "+", projectName );
	int index = m_BuildCommands.AddToTail();
	m_BuildCommands[index] = buildCommand;

	return m_TempGroupScriptFilename.Get();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int CVPC::ProcessCommandLine()
{
	SetupDefaultConditionals();

	DetermineSourcePath();

	// possible extensions determine operation mode beyond expected normal user case
	bool bScriptIsVGC = false;
	bool bScriptIsVPC = false;
	bool bScriptIsVCProj = false;
	bool bHasBuildCommand = false;
	const char *pScriptName = NULL;
	const char *pScriptNameVCProj = NULL;

	for ( int i = 1; i < m_nArgc; i++ )
	{
		const char *pArg = m_ppArgv[i];
		if ( V_stristr( pArg, ".vgc" ) )
		{
			// caller explicitly providing group
			pScriptName = pArg;
			bScriptIsVGC = true;
			bHasBuildCommand = true;
			break;
		}
		else if ( V_stristr( pArg, ".vpc" ) )
		{
			// caller is using a local vpc, i.e. one that is not hooked into the groups
			pScriptName = pArg;
			bScriptIsVPC = true;
			bHasBuildCommand = true;
			break;
		}
		else if ( !V_stricmp_fast( pArg, "/unity_update" ) )
		{
			// In this path, just update unity files and exit:
#ifdef DISALLOW_UNITY_FILE_EXCLUSION
			return 0;
#else
			return VPC_Unity_UpdateUnityFiles( ( m_ppArgv + i ), ( m_nArgc - i ) ) ? 0 : 1;
#endif
		}
		else
		{
			if ( V_stristr( pArg, ".vcproj" ) || V_stristr( pArg, ".vcxproj" ) )
			{
				// caller wants to re-gen the vcproj, this is commonly used by MSDEV to re-gen
				pScriptNameVCProj = pArg;
				bScriptIsVCProj = true;
				bHasBuildCommand = true;
				break;
			}
		}
	}

	for ( int i = 1; i < m_nArgc; i++ )
	{
		if ( m_ppArgv[i][0] == '-' || m_ppArgv[i][0] == '+' || m_ppArgv[i][0] == '*' || m_ppArgv[i][0] == '@' )
		{
			bHasBuildCommand = true;
			break;
		}
	}

	if ( bScriptIsVPC )
	{
		VPCWarning( "*** Using Explicit Local VPC Specification Override ***" );

		pScriptName = BuildTempGroupScript( pScriptName );
		bScriptIsVPC = false;
		bScriptIsVGC = true;
	}

	if ( !bScriptIsVGC )
	{
		// no script, use default group
		pScriptName = "vpc_scripts\\default.vgc";
		bScriptIsVGC = true;
	}

	// set the current directory, it is to be expected src, i.e. .\vpc_scripts\..
	SetDefaultSourcePath();

	char szCurrentDirectory[MAX_FIXED_PATH];
	V_GetCurrentDirectory( szCurrentDirectory, sizeof( szCurrentDirectory ) );
	m_StartDirectory = szCurrentDirectory;

	// parse and build tables from group script that options will reference
	if ( bScriptIsVGC )
	{
		VPC_ParseGroupScript( pScriptName );
	}

	if ( bScriptIsVCProj )
	{
		// this is commonly used as an extern tool in MSDEV to re-vpc in place
		// caller is msdev providing the vcproj name, solve to determine which project and generate
		FindProjectFromVCPROJ( pScriptNameVCProj, m_nArgc, m_ppArgv );
	}
	else
	{
		ParseBuildOptions( m_nArgc, m_ppArgv );
	}

	// set macros and conditionals derived from command-line options
	SetMacrosAndConditionals();

	// generate a CRC string derived from conditionals and command-line options
	GenerateOptionsCRCString();

	DetermineSolutionGenerator();

	// filter user's build commands
	// generate list of build targets
	CProjectDependencyGraph dependencyGraph;
	GenerateBuildSet( dependencyGraph );

	if ( !bHasBuildCommand && !HasP4SLNCommand() )
	{
		// spew usage
		m_bUsageOnly = true;
	}

	if ( m_bUsageOnly )
	{
		// spew only
		SpewUsage();
		return 0;
	}

	if ( !HandleP4SLN( m_pSolutionGenerator ) )
	{
		// iterate and build target projects
		if ( BuildTargetProjects() )
		{
			// now that we have valid project files, can generate solution
			HandleMKSLN( m_pSolutionGenerator,
                         m_pSolutionGenerator2,
                         dependencyGraph );
		}
	}

	if ( g_pVPC->GetTotalMissingFilesCount() > 0 )
	{
		g_pVPC->VPCWarning( "\n%d Total Files Missing.", g_pVPC->GetTotalMissingFilesCount() );
	}

	return 0;
}

//-----------------------------------------------------------------------------
//	main
//
//-----------------------------------------------------------------------------
void UpdateAutoExpDat();

// VPC is a DLL in Source.
#if defined( STEAM ) || defined( OSX ) || defined( LINUX ) || defined( STATIC_LINK )
int main( int argc, char **argv )
#else
int vpcmain( int argc, char **argv )
#endif
{
    // We statically link vstdlib so we need to make
    // a reference to the keyvalues system to keep it alive
    // for our use.
//    RequireKeyValuesSystem();
    
	g_pVPC = new CVPC();

	if ( !g_pVPC->Init( argc, argv ) )
	{
		return 0;
	}

#if defined( PLATFORM_WINDOWS_PC )
	UpdateAutoExpDat();
#endif

	int nRetVal = g_pVPC->ProcessCommandLine();
	delete g_pVPC;	
	g_pVPC = NULL;

	return nRetVal;
}

// VPC is a DLL in Source.
#if !( defined( STEAM ) || defined( OSX ) || defined( LINUX ) || defined( STATIC_LINK ) )
#include "ilaunchabledll.h"

// VPC is launched by vpc.exe, which is a copy of binlaunch.exe.
// All binlaunch does is setup the path to game\bin and load an ILaunchableDLL 
// interface out of a DLL with the same name as the exe.
class CVPCLaunchableDLL : public ILaunchableDLL
{
public:
	// All vpc.exe does is load the vpc DLL and run this.
	virtual int	main( int argc, char **argv )
	{
		return vpcmain( argc, argv );
	}
};

EXPOSE_SINGLE_INTERFACE( CVPCLaunchableDLL, ILaunchableDLL, LAUNCHABLE_DLL_INTERFACE_VERSION );
#endif


